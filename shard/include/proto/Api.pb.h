// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: proto/Api.proto

#ifndef PROTOBUF_proto_2fApi_2eproto__INCLUDED
#define PROTOBUF_proto_2fApi_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2004000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2004001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include "proto/Config.pb.h"
#include "proto/Request.pb.h"
// @@protoc_insertion_point(includes)

namespace Api {
namespace Proto {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_proto_2fApi_2eproto();
void protobuf_AssignDesc_proto_2fApi_2eproto();
void protobuf_ShutdownFile_proto_2fApi_2eproto();

class Update;
class CqQuery;
class CqShortTransact;
class CqCreateStorage;
class CqCreateView;
class CqUnlinkStorage;
class CqUnlinkView;
class CqUploadExtern;
class CqDownloadExtern;
class SrFin;
class SrRows;
class SrBlob;

enum Actions {
  kActNone = 0,
  kActInsert = 1,
  kActUpdate = 2
};
bool Actions_IsValid(int value);
const Actions Actions_MIN = kActNone;
const Actions Actions_MAX = kActUpdate;
const int Actions_ARRAYSIZE = Actions_MAX + 1;

enum ClientRequests {
  kCqQuery = 1,
  kCqShortTransact = 32,
  kCqCreateStorage = 256,
  kCqCreateView = 257,
  kCqUnlinkStorage = 258,
  kCqUnlinkView = 259,
  kCqUploadExtern = 260,
  kCqDownloadExtern = 261
};
bool ClientRequests_IsValid(int value);
const ClientRequests ClientRequests_MIN = kCqQuery;
const ClientRequests ClientRequests_MAX = kCqDownloadExtern;
const int ClientRequests_ARRAYSIZE = ClientRequests_MAX + 1;

enum ServerResponses {
  kSrFin = 1,
  kSrRows = 2,
  kSrBlob = 3
};
bool ServerResponses_IsValid(int value);
const ServerResponses ServerResponses_MIN = kSrFin;
const ServerResponses ServerResponses_MAX = kSrBlob;
const int ServerResponses_ARRAYSIZE = ServerResponses_MAX + 1;

enum EnumErrors {
  kErrNone = 0,
  kErrIllegalRequest = 1,
  kErrIllegalStorage = 128,
  kErrIllegalView = 129
};
bool EnumErrors_IsValid(int value);
const EnumErrors EnumErrors_MIN = kErrNone;
const EnumErrors EnumErrors_MAX = kErrIllegalView;
const int EnumErrors_ARRAYSIZE = EnumErrors_MAX + 1;

// ===================================================================

class Update : public ::google::protobuf::MessageLite {
 public:
  Update();
  virtual ~Update();
  
  Update(const Update& from);
  
  inline Update& operator=(const Update& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const Update& default_instance();
  
  void Swap(Update* other);
  
  // implements Message ----------------------------------------------
  
  Update* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const Update& from);
  void MergeFrom(const Update& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional .Api.Proto.Actions action = 1;
  inline bool has_action() const;
  inline void clear_action();
  static const int kActionFieldNumber = 1;
  inline Api::Proto::Actions action() const;
  inline void set_action(Api::Proto::Actions value);
  
  // optional int64 id = 2;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 2;
  inline ::google::protobuf::int64 id() const;
  inline void set_id(::google::protobuf::int64 value);
  
  // optional int32 storage_idx = 3;
  inline bool has_storage_idx() const;
  inline void clear_storage_idx();
  static const int kStorageIdxFieldNumber = 3;
  inline ::google::protobuf::int32 storage_idx() const;
  inline void set_storage_idx(::google::protobuf::int32 value);
  
  // optional string storage_name = 4;
  inline bool has_storage_name() const;
  inline void clear_storage_name();
  static const int kStorageNameFieldNumber = 4;
  inline const ::std::string& storage_name() const;
  inline void set_storage_name(const ::std::string& value);
  inline void set_storage_name(const char* value);
  inline void set_storage_name(const char* value, size_t size);
  inline ::std::string* mutable_storage_name();
  inline ::std::string* release_storage_name();
  
  // optional bytes buffer = 17;
  inline bool has_buffer() const;
  inline void clear_buffer();
  static const int kBufferFieldNumber = 17;
  inline const ::std::string& buffer() const;
  inline void set_buffer(const ::std::string& value);
  inline void set_buffer(const char* value);
  inline void set_buffer(const void* value, size_t size);
  inline ::std::string* mutable_buffer();
  inline ::std::string* release_buffer();
  
  // @@protoc_insertion_point(class_scope:Api.Proto.Update)
 private:
  inline void set_has_action();
  inline void clear_has_action();
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_storage_idx();
  inline void clear_has_storage_idx();
  inline void set_has_storage_name();
  inline void clear_has_storage_name();
  inline void set_has_buffer();
  inline void clear_has_buffer();
  
  ::google::protobuf::int64 id_;
  int action_;
  ::google::protobuf::int32 storage_idx_;
  ::std::string* storage_name_;
  ::std::string* buffer_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];
  
  friend void  protobuf_AddDesc_proto_2fApi_2eproto();
  friend void protobuf_AssignDesc_proto_2fApi_2eproto();
  friend void protobuf_ShutdownFile_proto_2fApi_2eproto();
  
  void InitAsDefaultInstance();
  static Update* default_instance_;
};
// -------------------------------------------------------------------

class CqQuery : public ::google::protobuf::MessageLite {
 public:
  CqQuery();
  virtual ~CqQuery();
  
  CqQuery(const CqQuery& from);
  
  inline CqQuery& operator=(const CqQuery& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const CqQuery& default_instance();
  
  void Swap(CqQuery* other);
  
  // implements Message ----------------------------------------------
  
  CqQuery* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CqQuery& from);
  void MergeFrom(const CqQuery& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional string view_name = 2;
  inline bool has_view_name() const;
  inline void clear_view_name();
  static const int kViewNameFieldNumber = 2;
  inline const ::std::string& view_name() const;
  inline void set_view_name(const ::std::string& value);
  inline void set_view_name(const char* value);
  inline void set_view_name(const char* value, size_t size);
  inline ::std::string* mutable_view_name();
  inline ::std::string* release_view_name();
  
  // repeated bytes keys = 3;
  inline int keys_size() const;
  inline void clear_keys();
  static const int kKeysFieldNumber = 3;
  inline const ::std::string& keys(int index) const;
  inline ::std::string* mutable_keys(int index);
  inline void set_keys(int index, const ::std::string& value);
  inline void set_keys(int index, const char* value);
  inline void set_keys(int index, const void* value, size_t size);
  inline ::std::string* add_keys();
  inline void add_keys(const ::std::string& value);
  inline void add_keys(const char* value);
  inline void add_keys(const void* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& keys() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_keys();
  
  // optional bytes from_key = 4;
  inline bool has_from_key() const;
  inline void clear_from_key();
  static const int kFromKeyFieldNumber = 4;
  inline const ::std::string& from_key() const;
  inline void set_from_key(const ::std::string& value);
  inline void set_from_key(const char* value);
  inline void set_from_key(const void* value, size_t size);
  inline ::std::string* mutable_from_key();
  inline ::std::string* release_from_key();
  
  // optional bytes to_key = 5;
  inline bool has_to_key() const;
  inline void clear_to_key();
  static const int kToKeyFieldNumber = 5;
  inline const ::std::string& to_key() const;
  inline void set_to_key(const ::std::string& value);
  inline void set_to_key(const char* value);
  inline void set_to_key(const void* value, size_t size);
  inline ::std::string* mutable_to_key();
  inline ::std::string* release_to_key();
  
  // optional uint32 limit = 6;
  inline bool has_limit() const;
  inline void clear_limit();
  static const int kLimitFieldNumber = 6;
  inline ::google::protobuf::uint32 limit() const;
  inline void set_limit(::google::protobuf::uint32 value);
  
  // @@protoc_insertion_point(class_scope:Api.Proto.CqQuery)
 private:
  inline void set_has_view_name();
  inline void clear_has_view_name();
  inline void set_has_from_key();
  inline void clear_has_from_key();
  inline void set_has_to_key();
  inline void clear_has_to_key();
  inline void set_has_limit();
  inline void clear_has_limit();
  
  ::std::string* view_name_;
  ::google::protobuf::RepeatedPtrField< ::std::string> keys_;
  ::std::string* from_key_;
  ::std::string* to_key_;
  ::google::protobuf::uint32 limit_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];
  
  friend void  protobuf_AddDesc_proto_2fApi_2eproto();
  friend void protobuf_AssignDesc_proto_2fApi_2eproto();
  friend void protobuf_ShutdownFile_proto_2fApi_2eproto();
  
  void InitAsDefaultInstance();
  static CqQuery* default_instance_;
};
// -------------------------------------------------------------------

class CqShortTransact : public ::google::protobuf::MessageLite {
 public:
  CqShortTransact();
  virtual ~CqShortTransact();
  
  CqShortTransact(const CqShortTransact& from);
  
  inline CqShortTransact& operator=(const CqShortTransact& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const CqShortTransact& default_instance();
  
  void Swap(CqShortTransact* other);
  
  // implements Message ----------------------------------------------
  
  CqShortTransact* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CqShortTransact& from);
  void MergeFrom(const CqShortTransact& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // repeated .Api.Proto.Update updates = 2;
  inline int updates_size() const;
  inline void clear_updates();
  static const int kUpdatesFieldNumber = 2;
  inline const ::Api::Proto::Update& updates(int index) const;
  inline ::Api::Proto::Update* mutable_updates(int index);
  inline ::Api::Proto::Update* add_updates();
  inline const ::google::protobuf::RepeatedPtrField< ::Api::Proto::Update >&
      updates() const;
  inline ::google::protobuf::RepeatedPtrField< ::Api::Proto::Update >*
      mutable_updates();
  
  // @@protoc_insertion_point(class_scope:Api.Proto.CqShortTransact)
 private:
  
  ::google::protobuf::RepeatedPtrField< ::Api::Proto::Update > updates_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_proto_2fApi_2eproto();
  friend void protobuf_AssignDesc_proto_2fApi_2eproto();
  friend void protobuf_ShutdownFile_proto_2fApi_2eproto();
  
  void InitAsDefaultInstance();
  static CqShortTransact* default_instance_;
};
// -------------------------------------------------------------------

class CqCreateStorage : public ::google::protobuf::MessageLite {
 public:
  CqCreateStorage();
  virtual ~CqCreateStorage();
  
  CqCreateStorage(const CqCreateStorage& from);
  
  inline CqCreateStorage& operator=(const CqCreateStorage& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const CqCreateStorage& default_instance();
  
  void Swap(CqCreateStorage* other);
  
  // implements Message ----------------------------------------------
  
  CqCreateStorage* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CqCreateStorage& from);
  void MergeFrom(const CqCreateStorage& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .Db.Proto.StorageConfig config = 1;
  inline bool has_config() const;
  inline void clear_config();
  static const int kConfigFieldNumber = 1;
  inline const ::Db::Proto::StorageConfig& config() const;
  inline ::Db::Proto::StorageConfig* mutable_config();
  inline ::Db::Proto::StorageConfig* release_config();
  
  // @@protoc_insertion_point(class_scope:Api.Proto.CqCreateStorage)
 private:
  inline void set_has_config();
  inline void clear_has_config();
  
  ::Db::Proto::StorageConfig* config_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_proto_2fApi_2eproto();
  friend void protobuf_AssignDesc_proto_2fApi_2eproto();
  friend void protobuf_ShutdownFile_proto_2fApi_2eproto();
  
  void InitAsDefaultInstance();
  static CqCreateStorage* default_instance_;
};
// -------------------------------------------------------------------

class CqCreateView : public ::google::protobuf::MessageLite {
 public:
  CqCreateView();
  virtual ~CqCreateView();
  
  CqCreateView(const CqCreateView& from);
  
  inline CqCreateView& operator=(const CqCreateView& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const CqCreateView& default_instance();
  
  void Swap(CqCreateView* other);
  
  // implements Message ----------------------------------------------
  
  CqCreateView* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CqCreateView& from);
  void MergeFrom(const CqCreateView& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .Db.Proto.ViewConfig config = 1;
  inline bool has_config() const;
  inline void clear_config();
  static const int kConfigFieldNumber = 1;
  inline const ::Db::Proto::ViewConfig& config() const;
  inline ::Db::Proto::ViewConfig* mutable_config();
  inline ::Db::Proto::ViewConfig* release_config();
  
  // @@protoc_insertion_point(class_scope:Api.Proto.CqCreateView)
 private:
  inline void set_has_config();
  inline void clear_has_config();
  
  ::Db::Proto::ViewConfig* config_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_proto_2fApi_2eproto();
  friend void protobuf_AssignDesc_proto_2fApi_2eproto();
  friend void protobuf_ShutdownFile_proto_2fApi_2eproto();
  
  void InitAsDefaultInstance();
  static CqCreateView* default_instance_;
};
// -------------------------------------------------------------------

class CqUnlinkStorage : public ::google::protobuf::MessageLite {
 public:
  CqUnlinkStorage();
  virtual ~CqUnlinkStorage();
  
  CqUnlinkStorage(const CqUnlinkStorage& from);
  
  inline CqUnlinkStorage& operator=(const CqUnlinkStorage& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const CqUnlinkStorage& default_instance();
  
  void Swap(CqUnlinkStorage* other);
  
  // implements Message ----------------------------------------------
  
  CqUnlinkStorage* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CqUnlinkStorage& from);
  void MergeFrom(const CqUnlinkStorage& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string identifier = 1;
  inline bool has_identifier() const;
  inline void clear_identifier();
  static const int kIdentifierFieldNumber = 1;
  inline const ::std::string& identifier() const;
  inline void set_identifier(const ::std::string& value);
  inline void set_identifier(const char* value);
  inline void set_identifier(const char* value, size_t size);
  inline ::std::string* mutable_identifier();
  inline ::std::string* release_identifier();
  
  // @@protoc_insertion_point(class_scope:Api.Proto.CqUnlinkStorage)
 private:
  inline void set_has_identifier();
  inline void clear_has_identifier();
  
  ::std::string* identifier_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_proto_2fApi_2eproto();
  friend void protobuf_AssignDesc_proto_2fApi_2eproto();
  friend void protobuf_ShutdownFile_proto_2fApi_2eproto();
  
  void InitAsDefaultInstance();
  static CqUnlinkStorage* default_instance_;
};
// -------------------------------------------------------------------

class CqUnlinkView : public ::google::protobuf::MessageLite {
 public:
  CqUnlinkView();
  virtual ~CqUnlinkView();
  
  CqUnlinkView(const CqUnlinkView& from);
  
  inline CqUnlinkView& operator=(const CqUnlinkView& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const CqUnlinkView& default_instance();
  
  void Swap(CqUnlinkView* other);
  
  // implements Message ----------------------------------------------
  
  CqUnlinkView* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CqUnlinkView& from);
  void MergeFrom(const CqUnlinkView& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string identifier = 1;
  inline bool has_identifier() const;
  inline void clear_identifier();
  static const int kIdentifierFieldNumber = 1;
  inline const ::std::string& identifier() const;
  inline void set_identifier(const ::std::string& value);
  inline void set_identifier(const char* value);
  inline void set_identifier(const char* value, size_t size);
  inline ::std::string* mutable_identifier();
  inline ::std::string* release_identifier();
  
  // @@protoc_insertion_point(class_scope:Api.Proto.CqUnlinkView)
 private:
  inline void set_has_identifier();
  inline void clear_has_identifier();
  
  ::std::string* identifier_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_proto_2fApi_2eproto();
  friend void protobuf_AssignDesc_proto_2fApi_2eproto();
  friend void protobuf_ShutdownFile_proto_2fApi_2eproto();
  
  void InitAsDefaultInstance();
  static CqUnlinkView* default_instance_;
};
// -------------------------------------------------------------------

class CqUploadExtern : public ::google::protobuf::MessageLite {
 public:
  CqUploadExtern();
  virtual ~CqUploadExtern();
  
  CqUploadExtern(const CqUploadExtern& from);
  
  inline CqUploadExtern& operator=(const CqUploadExtern& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const CqUploadExtern& default_instance();
  
  void Swap(CqUploadExtern* other);
  
  // implements Message ----------------------------------------------
  
  CqUploadExtern* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CqUploadExtern& from);
  void MergeFrom(const CqUploadExtern& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string file_name = 1;
  inline bool has_file_name() const;
  inline void clear_file_name();
  static const int kFileNameFieldNumber = 1;
  inline const ::std::string& file_name() const;
  inline void set_file_name(const ::std::string& value);
  inline void set_file_name(const char* value);
  inline void set_file_name(const char* value, size_t size);
  inline ::std::string* mutable_file_name();
  inline ::std::string* release_file_name();
  
  // required bytes buffer = 2;
  inline bool has_buffer() const;
  inline void clear_buffer();
  static const int kBufferFieldNumber = 2;
  inline const ::std::string& buffer() const;
  inline void set_buffer(const ::std::string& value);
  inline void set_buffer(const char* value);
  inline void set_buffer(const void* value, size_t size);
  inline ::std::string* mutable_buffer();
  inline ::std::string* release_buffer();
  
  // @@protoc_insertion_point(class_scope:Api.Proto.CqUploadExtern)
 private:
  inline void set_has_file_name();
  inline void clear_has_file_name();
  inline void set_has_buffer();
  inline void clear_has_buffer();
  
  ::std::string* file_name_;
  ::std::string* buffer_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_proto_2fApi_2eproto();
  friend void protobuf_AssignDesc_proto_2fApi_2eproto();
  friend void protobuf_ShutdownFile_proto_2fApi_2eproto();
  
  void InitAsDefaultInstance();
  static CqUploadExtern* default_instance_;
};
// -------------------------------------------------------------------

class CqDownloadExtern : public ::google::protobuf::MessageLite {
 public:
  CqDownloadExtern();
  virtual ~CqDownloadExtern();
  
  CqDownloadExtern(const CqDownloadExtern& from);
  
  inline CqDownloadExtern& operator=(const CqDownloadExtern& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const CqDownloadExtern& default_instance();
  
  void Swap(CqDownloadExtern* other);
  
  // implements Message ----------------------------------------------
  
  CqDownloadExtern* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CqDownloadExtern& from);
  void MergeFrom(const CqDownloadExtern& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string file_name = 1;
  inline bool has_file_name() const;
  inline void clear_file_name();
  static const int kFileNameFieldNumber = 1;
  inline const ::std::string& file_name() const;
  inline void set_file_name(const ::std::string& value);
  inline void set_file_name(const char* value);
  inline void set_file_name(const char* value, size_t size);
  inline ::std::string* mutable_file_name();
  inline ::std::string* release_file_name();
  
  // @@protoc_insertion_point(class_scope:Api.Proto.CqDownloadExtern)
 private:
  inline void set_has_file_name();
  inline void clear_has_file_name();
  
  ::std::string* file_name_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_proto_2fApi_2eproto();
  friend void protobuf_AssignDesc_proto_2fApi_2eproto();
  friend void protobuf_ShutdownFile_proto_2fApi_2eproto();
  
  void InitAsDefaultInstance();
  static CqDownloadExtern* default_instance_;
};
// -------------------------------------------------------------------

class SrFin : public ::google::protobuf::MessageLite {
 public:
  SrFin();
  virtual ~SrFin();
  
  SrFin(const SrFin& from);
  
  inline SrFin& operator=(const SrFin& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const SrFin& default_instance();
  
  void Swap(SrFin* other);
  
  // implements Message ----------------------------------------------
  
  SrFin* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const SrFin& from);
  void MergeFrom(const SrFin& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional bool success = 1;
  inline bool has_success() const;
  inline void clear_success();
  static const int kSuccessFieldNumber = 1;
  inline bool success() const;
  inline void set_success(bool value);
  
  // optional .Api.Proto.EnumErrors err_code = 2;
  inline bool has_err_code() const;
  inline void clear_err_code();
  static const int kErrCodeFieldNumber = 2;
  inline Api::Proto::EnumErrors err_code() const;
  inline void set_err_code(Api::Proto::EnumErrors value);
  
  // optional string err_msg = 3;
  inline bool has_err_msg() const;
  inline void clear_err_msg();
  static const int kErrMsgFieldNumber = 3;
  inline const ::std::string& err_msg() const;
  inline void set_err_msg(const ::std::string& value);
  inline void set_err_msg(const char* value);
  inline void set_err_msg(const char* value, size_t size);
  inline ::std::string* mutable_err_msg();
  inline ::std::string* release_err_msg();
  
  // @@protoc_insertion_point(class_scope:Api.Proto.SrFin)
 private:
  inline void set_has_success();
  inline void clear_has_success();
  inline void set_has_err_code();
  inline void clear_has_err_code();
  inline void set_has_err_msg();
  inline void clear_has_err_msg();
  
  bool success_;
  int err_code_;
  ::std::string* err_msg_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_proto_2fApi_2eproto();
  friend void protobuf_AssignDesc_proto_2fApi_2eproto();
  friend void protobuf_ShutdownFile_proto_2fApi_2eproto();
  
  void InitAsDefaultInstance();
  static SrFin* default_instance_;
};
// -------------------------------------------------------------------

class SrRows : public ::google::protobuf::MessageLite {
 public:
  SrRows();
  virtual ~SrRows();
  
  SrRows(const SrRows& from);
  
  inline SrRows& operator=(const SrRows& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const SrRows& default_instance();
  
  void Swap(SrRows* other);
  
  // implements Message ----------------------------------------------
  
  SrRows* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const SrRows& from);
  void MergeFrom(const SrRows& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // repeated bytes row_data = 1;
  inline int row_data_size() const;
  inline void clear_row_data();
  static const int kRowDataFieldNumber = 1;
  inline const ::std::string& row_data(int index) const;
  inline ::std::string* mutable_row_data(int index);
  inline void set_row_data(int index, const ::std::string& value);
  inline void set_row_data(int index, const char* value);
  inline void set_row_data(int index, const void* value, size_t size);
  inline ::std::string* add_row_data();
  inline void add_row_data(const ::std::string& value);
  inline void add_row_data(const char* value);
  inline void add_row_data(const void* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& row_data() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_row_data();
  
  // @@protoc_insertion_point(class_scope:Api.Proto.SrRows)
 private:
  
  ::google::protobuf::RepeatedPtrField< ::std::string> row_data_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_proto_2fApi_2eproto();
  friend void protobuf_AssignDesc_proto_2fApi_2eproto();
  friend void protobuf_ShutdownFile_proto_2fApi_2eproto();
  
  void InitAsDefaultInstance();
  static SrRows* default_instance_;
};
// -------------------------------------------------------------------

class SrBlob : public ::google::protobuf::MessageLite {
 public:
  SrBlob();
  virtual ~SrBlob();
  
  SrBlob(const SrBlob& from);
  
  inline SrBlob& operator=(const SrBlob& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const SrBlob& default_instance();
  
  void Swap(SrBlob* other);
  
  // implements Message ----------------------------------------------
  
  SrBlob* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const SrBlob& from);
  void MergeFrom(const SrBlob& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required bytes buffer = 1;
  inline bool has_buffer() const;
  inline void clear_buffer();
  static const int kBufferFieldNumber = 1;
  inline const ::std::string& buffer() const;
  inline void set_buffer(const ::std::string& value);
  inline void set_buffer(const char* value);
  inline void set_buffer(const void* value, size_t size);
  inline ::std::string* mutable_buffer();
  inline ::std::string* release_buffer();
  
  // @@protoc_insertion_point(class_scope:Api.Proto.SrBlob)
 private:
  inline void set_has_buffer();
  inline void clear_has_buffer();
  
  ::std::string* buffer_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_proto_2fApi_2eproto();
  friend void protobuf_AssignDesc_proto_2fApi_2eproto();
  friend void protobuf_ShutdownFile_proto_2fApi_2eproto();
  
  void InitAsDefaultInstance();
  static SrBlob* default_instance_;
};
// ===================================================================


// ===================================================================

// Update

// optional .Api.Proto.Actions action = 1;
inline bool Update::has_action() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Update::set_has_action() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Update::clear_has_action() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Update::clear_action() {
  action_ = 0;
  clear_has_action();
}
inline Api::Proto::Actions Update::action() const {
  return static_cast< Api::Proto::Actions >(action_);
}
inline void Update::set_action(Api::Proto::Actions value) {
  GOOGLE_DCHECK(Api::Proto::Actions_IsValid(value));
  set_has_action();
  action_ = value;
}

// optional int64 id = 2;
inline bool Update::has_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Update::set_has_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Update::clear_has_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Update::clear_id() {
  id_ = GOOGLE_LONGLONG(0);
  clear_has_id();
}
inline ::google::protobuf::int64 Update::id() const {
  return id_;
}
inline void Update::set_id(::google::protobuf::int64 value) {
  set_has_id();
  id_ = value;
}

// optional int32 storage_idx = 3;
inline bool Update::has_storage_idx() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Update::set_has_storage_idx() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Update::clear_has_storage_idx() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Update::clear_storage_idx() {
  storage_idx_ = 0;
  clear_has_storage_idx();
}
inline ::google::protobuf::int32 Update::storage_idx() const {
  return storage_idx_;
}
inline void Update::set_storage_idx(::google::protobuf::int32 value) {
  set_has_storage_idx();
  storage_idx_ = value;
}

// optional string storage_name = 4;
inline bool Update::has_storage_name() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Update::set_has_storage_name() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Update::clear_has_storage_name() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Update::clear_storage_name() {
  if (storage_name_ != &::google::protobuf::internal::kEmptyString) {
    storage_name_->clear();
  }
  clear_has_storage_name();
}
inline const ::std::string& Update::storage_name() const {
  return *storage_name_;
}
inline void Update::set_storage_name(const ::std::string& value) {
  set_has_storage_name();
  if (storage_name_ == &::google::protobuf::internal::kEmptyString) {
    storage_name_ = new ::std::string;
  }
  storage_name_->assign(value);
}
inline void Update::set_storage_name(const char* value) {
  set_has_storage_name();
  if (storage_name_ == &::google::protobuf::internal::kEmptyString) {
    storage_name_ = new ::std::string;
  }
  storage_name_->assign(value);
}
inline void Update::set_storage_name(const char* value, size_t size) {
  set_has_storage_name();
  if (storage_name_ == &::google::protobuf::internal::kEmptyString) {
    storage_name_ = new ::std::string;
  }
  storage_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Update::mutable_storage_name() {
  set_has_storage_name();
  if (storage_name_ == &::google::protobuf::internal::kEmptyString) {
    storage_name_ = new ::std::string;
  }
  return storage_name_;
}
inline ::std::string* Update::release_storage_name() {
  clear_has_storage_name();
  if (storage_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = storage_name_;
    storage_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional bytes buffer = 17;
inline bool Update::has_buffer() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Update::set_has_buffer() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Update::clear_has_buffer() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Update::clear_buffer() {
  if (buffer_ != &::google::protobuf::internal::kEmptyString) {
    buffer_->clear();
  }
  clear_has_buffer();
}
inline const ::std::string& Update::buffer() const {
  return *buffer_;
}
inline void Update::set_buffer(const ::std::string& value) {
  set_has_buffer();
  if (buffer_ == &::google::protobuf::internal::kEmptyString) {
    buffer_ = new ::std::string;
  }
  buffer_->assign(value);
}
inline void Update::set_buffer(const char* value) {
  set_has_buffer();
  if (buffer_ == &::google::protobuf::internal::kEmptyString) {
    buffer_ = new ::std::string;
  }
  buffer_->assign(value);
}
inline void Update::set_buffer(const void* value, size_t size) {
  set_has_buffer();
  if (buffer_ == &::google::protobuf::internal::kEmptyString) {
    buffer_ = new ::std::string;
  }
  buffer_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Update::mutable_buffer() {
  set_has_buffer();
  if (buffer_ == &::google::protobuf::internal::kEmptyString) {
    buffer_ = new ::std::string;
  }
  return buffer_;
}
inline ::std::string* Update::release_buffer() {
  clear_has_buffer();
  if (buffer_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = buffer_;
    buffer_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// CqQuery

// optional string view_name = 2;
inline bool CqQuery::has_view_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CqQuery::set_has_view_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CqQuery::clear_has_view_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CqQuery::clear_view_name() {
  if (view_name_ != &::google::protobuf::internal::kEmptyString) {
    view_name_->clear();
  }
  clear_has_view_name();
}
inline const ::std::string& CqQuery::view_name() const {
  return *view_name_;
}
inline void CqQuery::set_view_name(const ::std::string& value) {
  set_has_view_name();
  if (view_name_ == &::google::protobuf::internal::kEmptyString) {
    view_name_ = new ::std::string;
  }
  view_name_->assign(value);
}
inline void CqQuery::set_view_name(const char* value) {
  set_has_view_name();
  if (view_name_ == &::google::protobuf::internal::kEmptyString) {
    view_name_ = new ::std::string;
  }
  view_name_->assign(value);
}
inline void CqQuery::set_view_name(const char* value, size_t size) {
  set_has_view_name();
  if (view_name_ == &::google::protobuf::internal::kEmptyString) {
    view_name_ = new ::std::string;
  }
  view_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CqQuery::mutable_view_name() {
  set_has_view_name();
  if (view_name_ == &::google::protobuf::internal::kEmptyString) {
    view_name_ = new ::std::string;
  }
  return view_name_;
}
inline ::std::string* CqQuery::release_view_name() {
  clear_has_view_name();
  if (view_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = view_name_;
    view_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// repeated bytes keys = 3;
inline int CqQuery::keys_size() const {
  return keys_.size();
}
inline void CqQuery::clear_keys() {
  keys_.Clear();
}
inline const ::std::string& CqQuery::keys(int index) const {
  return keys_.Get(index);
}
inline ::std::string* CqQuery::mutable_keys(int index) {
  return keys_.Mutable(index);
}
inline void CqQuery::set_keys(int index, const ::std::string& value) {
  keys_.Mutable(index)->assign(value);
}
inline void CqQuery::set_keys(int index, const char* value) {
  keys_.Mutable(index)->assign(value);
}
inline void CqQuery::set_keys(int index, const void* value, size_t size) {
  keys_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CqQuery::add_keys() {
  return keys_.Add();
}
inline void CqQuery::add_keys(const ::std::string& value) {
  keys_.Add()->assign(value);
}
inline void CqQuery::add_keys(const char* value) {
  keys_.Add()->assign(value);
}
inline void CqQuery::add_keys(const void* value, size_t size) {
  keys_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
CqQuery::keys() const {
  return keys_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
CqQuery::mutable_keys() {
  return &keys_;
}

// optional bytes from_key = 4;
inline bool CqQuery::has_from_key() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CqQuery::set_has_from_key() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CqQuery::clear_has_from_key() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CqQuery::clear_from_key() {
  if (from_key_ != &::google::protobuf::internal::kEmptyString) {
    from_key_->clear();
  }
  clear_has_from_key();
}
inline const ::std::string& CqQuery::from_key() const {
  return *from_key_;
}
inline void CqQuery::set_from_key(const ::std::string& value) {
  set_has_from_key();
  if (from_key_ == &::google::protobuf::internal::kEmptyString) {
    from_key_ = new ::std::string;
  }
  from_key_->assign(value);
}
inline void CqQuery::set_from_key(const char* value) {
  set_has_from_key();
  if (from_key_ == &::google::protobuf::internal::kEmptyString) {
    from_key_ = new ::std::string;
  }
  from_key_->assign(value);
}
inline void CqQuery::set_from_key(const void* value, size_t size) {
  set_has_from_key();
  if (from_key_ == &::google::protobuf::internal::kEmptyString) {
    from_key_ = new ::std::string;
  }
  from_key_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CqQuery::mutable_from_key() {
  set_has_from_key();
  if (from_key_ == &::google::protobuf::internal::kEmptyString) {
    from_key_ = new ::std::string;
  }
  return from_key_;
}
inline ::std::string* CqQuery::release_from_key() {
  clear_has_from_key();
  if (from_key_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = from_key_;
    from_key_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional bytes to_key = 5;
inline bool CqQuery::has_to_key() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CqQuery::set_has_to_key() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CqQuery::clear_has_to_key() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CqQuery::clear_to_key() {
  if (to_key_ != &::google::protobuf::internal::kEmptyString) {
    to_key_->clear();
  }
  clear_has_to_key();
}
inline const ::std::string& CqQuery::to_key() const {
  return *to_key_;
}
inline void CqQuery::set_to_key(const ::std::string& value) {
  set_has_to_key();
  if (to_key_ == &::google::protobuf::internal::kEmptyString) {
    to_key_ = new ::std::string;
  }
  to_key_->assign(value);
}
inline void CqQuery::set_to_key(const char* value) {
  set_has_to_key();
  if (to_key_ == &::google::protobuf::internal::kEmptyString) {
    to_key_ = new ::std::string;
  }
  to_key_->assign(value);
}
inline void CqQuery::set_to_key(const void* value, size_t size) {
  set_has_to_key();
  if (to_key_ == &::google::protobuf::internal::kEmptyString) {
    to_key_ = new ::std::string;
  }
  to_key_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CqQuery::mutable_to_key() {
  set_has_to_key();
  if (to_key_ == &::google::protobuf::internal::kEmptyString) {
    to_key_ = new ::std::string;
  }
  return to_key_;
}
inline ::std::string* CqQuery::release_to_key() {
  clear_has_to_key();
  if (to_key_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = to_key_;
    to_key_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional uint32 limit = 6;
inline bool CqQuery::has_limit() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CqQuery::set_has_limit() {
  _has_bits_[0] |= 0x00000010u;
}
inline void CqQuery::clear_has_limit() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void CqQuery::clear_limit() {
  limit_ = 0u;
  clear_has_limit();
}
inline ::google::protobuf::uint32 CqQuery::limit() const {
  return limit_;
}
inline void CqQuery::set_limit(::google::protobuf::uint32 value) {
  set_has_limit();
  limit_ = value;
}

// -------------------------------------------------------------------

// CqShortTransact

// repeated .Api.Proto.Update updates = 2;
inline int CqShortTransact::updates_size() const {
  return updates_.size();
}
inline void CqShortTransact::clear_updates() {
  updates_.Clear();
}
inline const ::Api::Proto::Update& CqShortTransact::updates(int index) const {
  return updates_.Get(index);
}
inline ::Api::Proto::Update* CqShortTransact::mutable_updates(int index) {
  return updates_.Mutable(index);
}
inline ::Api::Proto::Update* CqShortTransact::add_updates() {
  return updates_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Api::Proto::Update >&
CqShortTransact::updates() const {
  return updates_;
}
inline ::google::protobuf::RepeatedPtrField< ::Api::Proto::Update >*
CqShortTransact::mutable_updates() {
  return &updates_;
}

// -------------------------------------------------------------------

// CqCreateStorage

// required .Db.Proto.StorageConfig config = 1;
inline bool CqCreateStorage::has_config() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CqCreateStorage::set_has_config() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CqCreateStorage::clear_has_config() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CqCreateStorage::clear_config() {
  if (config_ != NULL) config_->::Db::Proto::StorageConfig::Clear();
  clear_has_config();
}
inline const ::Db::Proto::StorageConfig& CqCreateStorage::config() const {
  return config_ != NULL ? *config_ : *default_instance_->config_;
}
inline ::Db::Proto::StorageConfig* CqCreateStorage::mutable_config() {
  set_has_config();
  if (config_ == NULL) config_ = new ::Db::Proto::StorageConfig;
  return config_;
}
inline ::Db::Proto::StorageConfig* CqCreateStorage::release_config() {
  clear_has_config();
  ::Db::Proto::StorageConfig* temp = config_;
  config_ = NULL;
  return temp;
}

// -------------------------------------------------------------------

// CqCreateView

// required .Db.Proto.ViewConfig config = 1;
inline bool CqCreateView::has_config() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CqCreateView::set_has_config() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CqCreateView::clear_has_config() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CqCreateView::clear_config() {
  if (config_ != NULL) config_->::Db::Proto::ViewConfig::Clear();
  clear_has_config();
}
inline const ::Db::Proto::ViewConfig& CqCreateView::config() const {
  return config_ != NULL ? *config_ : *default_instance_->config_;
}
inline ::Db::Proto::ViewConfig* CqCreateView::mutable_config() {
  set_has_config();
  if (config_ == NULL) config_ = new ::Db::Proto::ViewConfig;
  return config_;
}
inline ::Db::Proto::ViewConfig* CqCreateView::release_config() {
  clear_has_config();
  ::Db::Proto::ViewConfig* temp = config_;
  config_ = NULL;
  return temp;
}

// -------------------------------------------------------------------

// CqUnlinkStorage

// required string identifier = 1;
inline bool CqUnlinkStorage::has_identifier() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CqUnlinkStorage::set_has_identifier() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CqUnlinkStorage::clear_has_identifier() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CqUnlinkStorage::clear_identifier() {
  if (identifier_ != &::google::protobuf::internal::kEmptyString) {
    identifier_->clear();
  }
  clear_has_identifier();
}
inline const ::std::string& CqUnlinkStorage::identifier() const {
  return *identifier_;
}
inline void CqUnlinkStorage::set_identifier(const ::std::string& value) {
  set_has_identifier();
  if (identifier_ == &::google::protobuf::internal::kEmptyString) {
    identifier_ = new ::std::string;
  }
  identifier_->assign(value);
}
inline void CqUnlinkStorage::set_identifier(const char* value) {
  set_has_identifier();
  if (identifier_ == &::google::protobuf::internal::kEmptyString) {
    identifier_ = new ::std::string;
  }
  identifier_->assign(value);
}
inline void CqUnlinkStorage::set_identifier(const char* value, size_t size) {
  set_has_identifier();
  if (identifier_ == &::google::protobuf::internal::kEmptyString) {
    identifier_ = new ::std::string;
  }
  identifier_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CqUnlinkStorage::mutable_identifier() {
  set_has_identifier();
  if (identifier_ == &::google::protobuf::internal::kEmptyString) {
    identifier_ = new ::std::string;
  }
  return identifier_;
}
inline ::std::string* CqUnlinkStorage::release_identifier() {
  clear_has_identifier();
  if (identifier_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = identifier_;
    identifier_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// CqUnlinkView

// required string identifier = 1;
inline bool CqUnlinkView::has_identifier() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CqUnlinkView::set_has_identifier() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CqUnlinkView::clear_has_identifier() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CqUnlinkView::clear_identifier() {
  if (identifier_ != &::google::protobuf::internal::kEmptyString) {
    identifier_->clear();
  }
  clear_has_identifier();
}
inline const ::std::string& CqUnlinkView::identifier() const {
  return *identifier_;
}
inline void CqUnlinkView::set_identifier(const ::std::string& value) {
  set_has_identifier();
  if (identifier_ == &::google::protobuf::internal::kEmptyString) {
    identifier_ = new ::std::string;
  }
  identifier_->assign(value);
}
inline void CqUnlinkView::set_identifier(const char* value) {
  set_has_identifier();
  if (identifier_ == &::google::protobuf::internal::kEmptyString) {
    identifier_ = new ::std::string;
  }
  identifier_->assign(value);
}
inline void CqUnlinkView::set_identifier(const char* value, size_t size) {
  set_has_identifier();
  if (identifier_ == &::google::protobuf::internal::kEmptyString) {
    identifier_ = new ::std::string;
  }
  identifier_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CqUnlinkView::mutable_identifier() {
  set_has_identifier();
  if (identifier_ == &::google::protobuf::internal::kEmptyString) {
    identifier_ = new ::std::string;
  }
  return identifier_;
}
inline ::std::string* CqUnlinkView::release_identifier() {
  clear_has_identifier();
  if (identifier_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = identifier_;
    identifier_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// CqUploadExtern

// required string file_name = 1;
inline bool CqUploadExtern::has_file_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CqUploadExtern::set_has_file_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CqUploadExtern::clear_has_file_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CqUploadExtern::clear_file_name() {
  if (file_name_ != &::google::protobuf::internal::kEmptyString) {
    file_name_->clear();
  }
  clear_has_file_name();
}
inline const ::std::string& CqUploadExtern::file_name() const {
  return *file_name_;
}
inline void CqUploadExtern::set_file_name(const ::std::string& value) {
  set_has_file_name();
  if (file_name_ == &::google::protobuf::internal::kEmptyString) {
    file_name_ = new ::std::string;
  }
  file_name_->assign(value);
}
inline void CqUploadExtern::set_file_name(const char* value) {
  set_has_file_name();
  if (file_name_ == &::google::protobuf::internal::kEmptyString) {
    file_name_ = new ::std::string;
  }
  file_name_->assign(value);
}
inline void CqUploadExtern::set_file_name(const char* value, size_t size) {
  set_has_file_name();
  if (file_name_ == &::google::protobuf::internal::kEmptyString) {
    file_name_ = new ::std::string;
  }
  file_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CqUploadExtern::mutable_file_name() {
  set_has_file_name();
  if (file_name_ == &::google::protobuf::internal::kEmptyString) {
    file_name_ = new ::std::string;
  }
  return file_name_;
}
inline ::std::string* CqUploadExtern::release_file_name() {
  clear_has_file_name();
  if (file_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = file_name_;
    file_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required bytes buffer = 2;
inline bool CqUploadExtern::has_buffer() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CqUploadExtern::set_has_buffer() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CqUploadExtern::clear_has_buffer() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CqUploadExtern::clear_buffer() {
  if (buffer_ != &::google::protobuf::internal::kEmptyString) {
    buffer_->clear();
  }
  clear_has_buffer();
}
inline const ::std::string& CqUploadExtern::buffer() const {
  return *buffer_;
}
inline void CqUploadExtern::set_buffer(const ::std::string& value) {
  set_has_buffer();
  if (buffer_ == &::google::protobuf::internal::kEmptyString) {
    buffer_ = new ::std::string;
  }
  buffer_->assign(value);
}
inline void CqUploadExtern::set_buffer(const char* value) {
  set_has_buffer();
  if (buffer_ == &::google::protobuf::internal::kEmptyString) {
    buffer_ = new ::std::string;
  }
  buffer_->assign(value);
}
inline void CqUploadExtern::set_buffer(const void* value, size_t size) {
  set_has_buffer();
  if (buffer_ == &::google::protobuf::internal::kEmptyString) {
    buffer_ = new ::std::string;
  }
  buffer_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CqUploadExtern::mutable_buffer() {
  set_has_buffer();
  if (buffer_ == &::google::protobuf::internal::kEmptyString) {
    buffer_ = new ::std::string;
  }
  return buffer_;
}
inline ::std::string* CqUploadExtern::release_buffer() {
  clear_has_buffer();
  if (buffer_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = buffer_;
    buffer_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// CqDownloadExtern

// required string file_name = 1;
inline bool CqDownloadExtern::has_file_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CqDownloadExtern::set_has_file_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CqDownloadExtern::clear_has_file_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CqDownloadExtern::clear_file_name() {
  if (file_name_ != &::google::protobuf::internal::kEmptyString) {
    file_name_->clear();
  }
  clear_has_file_name();
}
inline const ::std::string& CqDownloadExtern::file_name() const {
  return *file_name_;
}
inline void CqDownloadExtern::set_file_name(const ::std::string& value) {
  set_has_file_name();
  if (file_name_ == &::google::protobuf::internal::kEmptyString) {
    file_name_ = new ::std::string;
  }
  file_name_->assign(value);
}
inline void CqDownloadExtern::set_file_name(const char* value) {
  set_has_file_name();
  if (file_name_ == &::google::protobuf::internal::kEmptyString) {
    file_name_ = new ::std::string;
  }
  file_name_->assign(value);
}
inline void CqDownloadExtern::set_file_name(const char* value, size_t size) {
  set_has_file_name();
  if (file_name_ == &::google::protobuf::internal::kEmptyString) {
    file_name_ = new ::std::string;
  }
  file_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CqDownloadExtern::mutable_file_name() {
  set_has_file_name();
  if (file_name_ == &::google::protobuf::internal::kEmptyString) {
    file_name_ = new ::std::string;
  }
  return file_name_;
}
inline ::std::string* CqDownloadExtern::release_file_name() {
  clear_has_file_name();
  if (file_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = file_name_;
    file_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// SrFin

// optional bool success = 1;
inline bool SrFin::has_success() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SrFin::set_has_success() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SrFin::clear_has_success() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SrFin::clear_success() {
  success_ = false;
  clear_has_success();
}
inline bool SrFin::success() const {
  return success_;
}
inline void SrFin::set_success(bool value) {
  set_has_success();
  success_ = value;
}

// optional .Api.Proto.EnumErrors err_code = 2;
inline bool SrFin::has_err_code() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SrFin::set_has_err_code() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SrFin::clear_has_err_code() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SrFin::clear_err_code() {
  err_code_ = 0;
  clear_has_err_code();
}
inline Api::Proto::EnumErrors SrFin::err_code() const {
  return static_cast< Api::Proto::EnumErrors >(err_code_);
}
inline void SrFin::set_err_code(Api::Proto::EnumErrors value) {
  GOOGLE_DCHECK(Api::Proto::EnumErrors_IsValid(value));
  set_has_err_code();
  err_code_ = value;
}

// optional string err_msg = 3;
inline bool SrFin::has_err_msg() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SrFin::set_has_err_msg() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SrFin::clear_has_err_msg() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SrFin::clear_err_msg() {
  if (err_msg_ != &::google::protobuf::internal::kEmptyString) {
    err_msg_->clear();
  }
  clear_has_err_msg();
}
inline const ::std::string& SrFin::err_msg() const {
  return *err_msg_;
}
inline void SrFin::set_err_msg(const ::std::string& value) {
  set_has_err_msg();
  if (err_msg_ == &::google::protobuf::internal::kEmptyString) {
    err_msg_ = new ::std::string;
  }
  err_msg_->assign(value);
}
inline void SrFin::set_err_msg(const char* value) {
  set_has_err_msg();
  if (err_msg_ == &::google::protobuf::internal::kEmptyString) {
    err_msg_ = new ::std::string;
  }
  err_msg_->assign(value);
}
inline void SrFin::set_err_msg(const char* value, size_t size) {
  set_has_err_msg();
  if (err_msg_ == &::google::protobuf::internal::kEmptyString) {
    err_msg_ = new ::std::string;
  }
  err_msg_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SrFin::mutable_err_msg() {
  set_has_err_msg();
  if (err_msg_ == &::google::protobuf::internal::kEmptyString) {
    err_msg_ = new ::std::string;
  }
  return err_msg_;
}
inline ::std::string* SrFin::release_err_msg() {
  clear_has_err_msg();
  if (err_msg_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = err_msg_;
    err_msg_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// SrRows

// repeated bytes row_data = 1;
inline int SrRows::row_data_size() const {
  return row_data_.size();
}
inline void SrRows::clear_row_data() {
  row_data_.Clear();
}
inline const ::std::string& SrRows::row_data(int index) const {
  return row_data_.Get(index);
}
inline ::std::string* SrRows::mutable_row_data(int index) {
  return row_data_.Mutable(index);
}
inline void SrRows::set_row_data(int index, const ::std::string& value) {
  row_data_.Mutable(index)->assign(value);
}
inline void SrRows::set_row_data(int index, const char* value) {
  row_data_.Mutable(index)->assign(value);
}
inline void SrRows::set_row_data(int index, const void* value, size_t size) {
  row_data_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SrRows::add_row_data() {
  return row_data_.Add();
}
inline void SrRows::add_row_data(const ::std::string& value) {
  row_data_.Add()->assign(value);
}
inline void SrRows::add_row_data(const char* value) {
  row_data_.Add()->assign(value);
}
inline void SrRows::add_row_data(const void* value, size_t size) {
  row_data_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
SrRows::row_data() const {
  return row_data_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
SrRows::mutable_row_data() {
  return &row_data_;
}

// -------------------------------------------------------------------

// SrBlob

// required bytes buffer = 1;
inline bool SrBlob::has_buffer() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SrBlob::set_has_buffer() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SrBlob::clear_has_buffer() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SrBlob::clear_buffer() {
  if (buffer_ != &::google::protobuf::internal::kEmptyString) {
    buffer_->clear();
  }
  clear_has_buffer();
}
inline const ::std::string& SrBlob::buffer() const {
  return *buffer_;
}
inline void SrBlob::set_buffer(const ::std::string& value) {
  set_has_buffer();
  if (buffer_ == &::google::protobuf::internal::kEmptyString) {
    buffer_ = new ::std::string;
  }
  buffer_->assign(value);
}
inline void SrBlob::set_buffer(const char* value) {
  set_has_buffer();
  if (buffer_ == &::google::protobuf::internal::kEmptyString) {
    buffer_ = new ::std::string;
  }
  buffer_->assign(value);
}
inline void SrBlob::set_buffer(const void* value, size_t size) {
  set_has_buffer();
  if (buffer_ == &::google::protobuf::internal::kEmptyString) {
    buffer_ = new ::std::string;
  }
  buffer_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SrBlob::mutable_buffer() {
  set_has_buffer();
  if (buffer_ == &::google::protobuf::internal::kEmptyString) {
    buffer_ = new ::std::string;
  }
  return buffer_;
}
inline ::std::string* SrBlob::release_buffer() {
  clear_has_buffer();
  if (buffer_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = buffer_;
    buffer_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace Proto
}  // namespace Api

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_proto_2fApi_2eproto__INCLUDED
