// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: proto/Api.proto

#ifndef PROTOBUF_proto_2fApi_2eproto__INCLUDED
#define PROTOBUF_proto_2fApi_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2004000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2004001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include "proto/Config.pb.h"
// @@protoc_insertion_point(includes)

namespace Api {
namespace Proto {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_proto_2fApi_2eproto();
void protobuf_AssignDesc_proto_2fApi_2eproto();
void protobuf_ShutdownFile_proto_2fApi_2eproto();

class Mutation;
class Constraint;
class CqQuery;
class CqShortTransact;
class CqTransaction;
class CqUpdate;
class CqApply;
class CqCreateStorage;
class CqCreateView;
class CqUnlinkStorage;
class CqUnlinkView;
class CqUploadExtern;
class CqDownloadExtern;
class CqShutdown;
class SrFin;
class SrFin_MutationInfo;
class SrRows;
class SrBlob;

enum Mutation_Type {
  Mutation_Type_kTypeNone = 0,
  Mutation_Type_kTypeInsert = 1,
  Mutation_Type_kTypeModify = 2
};
bool Mutation_Type_IsValid(int value);
const Mutation_Type Mutation_Type_Type_MIN = Mutation_Type_kTypeNone;
const Mutation_Type Mutation_Type_Type_MAX = Mutation_Type_kTypeModify;
const int Mutation_Type_Type_ARRAYSIZE = Mutation_Type_Type_MAX + 1;

enum Constraint_Type {
  Constraint_Type_kTypeNone = 0,
  Constraint_Type_kTypeDocumentState = 1
};
bool Constraint_Type_IsValid(int value);
const Constraint_Type Constraint_Type_Type_MIN = Constraint_Type_kTypeNone;
const Constraint_Type Constraint_Type_Type_MAX = Constraint_Type_kTypeDocumentState;
const int Constraint_Type_Type_ARRAYSIZE = Constraint_Type_Type_MAX + 1;

enum CqApply_Type {
  CqApply_Type_kTypeNone = 0,
  CqApply_Type_kTypeSubmit = 1,
  CqApply_Type_kTypeSubmitCommit = 2,
  CqApply_Type_kTypeCommit = 3,
  CqApply_Type_kTypeRollback = 4
};
bool CqApply_Type_IsValid(int value);
const CqApply_Type CqApply_Type_Type_MIN = CqApply_Type_kTypeNone;
const CqApply_Type CqApply_Type_Type_MAX = CqApply_Type_kTypeRollback;
const int CqApply_Type_Type_ARRAYSIZE = CqApply_Type_Type_MAX + 1;

enum ErrorCode {
  kCodeNone = 0,
  kCodeSuccess = 1,
  kCodeIllegalRequest = 2,
  kCodeParseError = 3,
  kCodeIllegalState = 4,
  kCodeSubmitConstraintViolation = 32,
  kCodeSubmitConstraintConflict = 33,
  kCodeSubmitMutationConflict = 34,
  kCodeIllegalStorage = 128,
  kCodeIllegalView = 129
};
bool ErrorCode_IsValid(int value);
const ErrorCode ErrorCode_MIN = kCodeNone;
const ErrorCode ErrorCode_MAX = kCodeIllegalView;
const int ErrorCode_ARRAYSIZE = ErrorCode_MAX + 1;

enum ClientRequests {
  kCqQuery = 1,
  kCqShortTransact = 2,
  kCqTransaction = 3,
  kCqUpdate = 4,
  kCqApply = 5,
  kCqCreateStorage = 256,
  kCqCreateView = 257,
  kCqUnlinkStorage = 258,
  kCqUnlinkView = 259,
  kCqUploadExtern = 260,
  kCqDownloadExtern = 261,
  kCqShutdown = 262
};
bool ClientRequests_IsValid(int value);
const ClientRequests ClientRequests_MIN = kCqQuery;
const ClientRequests ClientRequests_MAX = kCqShutdown;
const int ClientRequests_ARRAYSIZE = ClientRequests_MAX + 1;

enum ServerResponses {
  kSrFin = 1,
  kSrRows = 2,
  kSrBlob = 3
};
bool ServerResponses_IsValid(int value);
const ServerResponses ServerResponses_MIN = kSrFin;
const ServerResponses ServerResponses_MAX = kSrBlob;
const int ServerResponses_ARRAYSIZE = ServerResponses_MAX + 1;

// ===================================================================

class Mutation : public ::google::protobuf::MessageLite {
 public:
  Mutation();
  virtual ~Mutation();
  
  Mutation(const Mutation& from);
  
  inline Mutation& operator=(const Mutation& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const Mutation& default_instance();
  
  void Swap(Mutation* other);
  
  // implements Message ----------------------------------------------
  
  Mutation* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const Mutation& from);
  void MergeFrom(const Mutation& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  typedef Mutation_Type Type;
  static const Type kTypeNone = Mutation_Type_kTypeNone;
  static const Type kTypeInsert = Mutation_Type_kTypeInsert;
  static const Type kTypeModify = Mutation_Type_kTypeModify;
  static inline bool Type_IsValid(int value) {
    return Mutation_Type_IsValid(value);
  }
  static const Type Type_MIN =
    Mutation_Type_Type_MIN;
  static const Type Type_MAX =
    Mutation_Type_Type_MAX;
  static const int Type_ARRAYSIZE =
    Mutation_Type_Type_ARRAYSIZE;
  
  // accessors -------------------------------------------------------
  
  // optional .Api.Proto.Mutation.Type type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::Api::Proto::Mutation_Type type() const;
  inline void set_type(::Api::Proto::Mutation_Type value);
  
  // optional int64 document_id = 2;
  inline bool has_document_id() const;
  inline void clear_document_id();
  static const int kDocumentIdFieldNumber = 2;
  inline ::google::protobuf::int64 document_id() const;
  inline void set_document_id(::google::protobuf::int64 value);
  
  // optional string storage_name = 3;
  inline bool has_storage_name() const;
  inline void clear_storage_name();
  static const int kStorageNameFieldNumber = 3;
  inline const ::std::string& storage_name() const;
  inline void set_storage_name(const ::std::string& value);
  inline void set_storage_name(const char* value);
  inline void set_storage_name(const char* value, size_t size);
  inline ::std::string* mutable_storage_name();
  inline ::std::string* release_storage_name();
  
  // optional bytes buffer = 4;
  inline bool has_buffer() const;
  inline void clear_buffer();
  static const int kBufferFieldNumber = 4;
  inline const ::std::string& buffer() const;
  inline void set_buffer(const ::std::string& value);
  inline void set_buffer(const char* value);
  inline void set_buffer(const void* value, size_t size);
  inline ::std::string* mutable_buffer();
  inline ::std::string* release_buffer();
  
  // @@protoc_insertion_point(class_scope:Api.Proto.Mutation)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_document_id();
  inline void clear_has_document_id();
  inline void set_has_storage_name();
  inline void clear_has_storage_name();
  inline void set_has_buffer();
  inline void clear_has_buffer();
  
  ::google::protobuf::int64 document_id_;
  ::std::string* storage_name_;
  ::std::string* buffer_;
  int type_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];
  
  friend void  protobuf_AddDesc_proto_2fApi_2eproto();
  friend void protobuf_AssignDesc_proto_2fApi_2eproto();
  friend void protobuf_ShutdownFile_proto_2fApi_2eproto();
  
  void InitAsDefaultInstance();
  static Mutation* default_instance_;
};
// -------------------------------------------------------------------

class Constraint : public ::google::protobuf::MessageLite {
 public:
  Constraint();
  virtual ~Constraint();
  
  Constraint(const Constraint& from);
  
  inline Constraint& operator=(const Constraint& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const Constraint& default_instance();
  
  void Swap(Constraint* other);
  
  // implements Message ----------------------------------------------
  
  Constraint* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const Constraint& from);
  void MergeFrom(const Constraint& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  typedef Constraint_Type Type;
  static const Type kTypeNone = Constraint_Type_kTypeNone;
  static const Type kTypeDocumentState = Constraint_Type_kTypeDocumentState;
  static inline bool Type_IsValid(int value) {
    return Constraint_Type_IsValid(value);
  }
  static const Type Type_MIN =
    Constraint_Type_Type_MIN;
  static const Type Type_MAX =
    Constraint_Type_Type_MAX;
  static const int Type_ARRAYSIZE =
    Constraint_Type_Type_ARRAYSIZE;
  
  // accessors -------------------------------------------------------
  
  // optional .Api.Proto.Constraint.Type type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::Api::Proto::Constraint_Type type() const;
  inline void set_type(::Api::Proto::Constraint_Type value);
  
  // optional string storage_name = 2;
  inline bool has_storage_name() const;
  inline void clear_storage_name();
  static const int kStorageNameFieldNumber = 2;
  inline const ::std::string& storage_name() const;
  inline void set_storage_name(const ::std::string& value);
  inline void set_storage_name(const char* value);
  inline void set_storage_name(const char* value, size_t size);
  inline ::std::string* mutable_storage_name();
  inline ::std::string* release_storage_name();
  
  // optional int64 document_id = 3;
  inline bool has_document_id() const;
  inline void clear_document_id();
  static const int kDocumentIdFieldNumber = 3;
  inline ::google::protobuf::int64 document_id() const;
  inline void set_document_id(::google::protobuf::int64 value);
  
  // optional int64 sequence_id = 4;
  inline bool has_sequence_id() const;
  inline void clear_sequence_id();
  static const int kSequenceIdFieldNumber = 4;
  inline ::google::protobuf::int64 sequence_id() const;
  inline void set_sequence_id(::google::protobuf::int64 value);
  
  // optional bool must_exist = 5;
  inline bool has_must_exist() const;
  inline void clear_must_exist();
  static const int kMustExistFieldNumber = 5;
  inline bool must_exist() const;
  inline void set_must_exist(bool value);
  
  // optional bool match_sequence_id = 6;
  inline bool has_match_sequence_id() const;
  inline void clear_match_sequence_id();
  static const int kMatchSequenceIdFieldNumber = 6;
  inline bool match_sequence_id() const;
  inline void set_match_sequence_id(bool value);
  
  // @@protoc_insertion_point(class_scope:Api.Proto.Constraint)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_storage_name();
  inline void clear_has_storage_name();
  inline void set_has_document_id();
  inline void clear_has_document_id();
  inline void set_has_sequence_id();
  inline void clear_has_sequence_id();
  inline void set_has_must_exist();
  inline void clear_has_must_exist();
  inline void set_has_match_sequence_id();
  inline void clear_has_match_sequence_id();
  
  ::std::string* storage_name_;
  ::google::protobuf::int64 document_id_;
  ::google::protobuf::int64 sequence_id_;
  int type_;
  bool must_exist_;
  bool match_sequence_id_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];
  
  friend void  protobuf_AddDesc_proto_2fApi_2eproto();
  friend void protobuf_AssignDesc_proto_2fApi_2eproto();
  friend void protobuf_ShutdownFile_proto_2fApi_2eproto();
  
  void InitAsDefaultInstance();
  static Constraint* default_instance_;
};
// -------------------------------------------------------------------

class CqQuery : public ::google::protobuf::MessageLite {
 public:
  CqQuery();
  virtual ~CqQuery();
  
  CqQuery(const CqQuery& from);
  
  inline CqQuery& operator=(const CqQuery& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const CqQuery& default_instance();
  
  void Swap(CqQuery* other);
  
  // implements Message ----------------------------------------------
  
  CqQuery* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CqQuery& from);
  void MergeFrom(const CqQuery& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional string view_name = 1;
  inline bool has_view_name() const;
  inline void clear_view_name();
  static const int kViewNameFieldNumber = 1;
  inline const ::std::string& view_name() const;
  inline void set_view_name(const ::std::string& value);
  inline void set_view_name(const char* value);
  inline void set_view_name(const char* value, size_t size);
  inline ::std::string* mutable_view_name();
  inline ::std::string* release_view_name();
  
  // optional int64 sequence_id = 2;
  inline bool has_sequence_id() const;
  inline void clear_sequence_id();
  static const int kSequenceIdFieldNumber = 2;
  inline ::google::protobuf::int64 sequence_id() const;
  inline void set_sequence_id(::google::protobuf::int64 value);
  
  // repeated bytes keys = 3;
  inline int keys_size() const;
  inline void clear_keys();
  static const int kKeysFieldNumber = 3;
  inline const ::std::string& keys(int index) const;
  inline ::std::string* mutable_keys(int index);
  inline void set_keys(int index, const ::std::string& value);
  inline void set_keys(int index, const char* value);
  inline void set_keys(int index, const void* value, size_t size);
  inline ::std::string* add_keys();
  inline void add_keys(const ::std::string& value);
  inline void add_keys(const char* value);
  inline void add_keys(const void* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& keys() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_keys();
  
  // optional bytes from_key = 4;
  inline bool has_from_key() const;
  inline void clear_from_key();
  static const int kFromKeyFieldNumber = 4;
  inline const ::std::string& from_key() const;
  inline void set_from_key(const ::std::string& value);
  inline void set_from_key(const char* value);
  inline void set_from_key(const void* value, size_t size);
  inline ::std::string* mutable_from_key();
  inline ::std::string* release_from_key();
  
  // optional bytes to_key = 5;
  inline bool has_to_key() const;
  inline void clear_to_key();
  static const int kToKeyFieldNumber = 5;
  inline const ::std::string& to_key() const;
  inline void set_to_key(const ::std::string& value);
  inline void set_to_key(const char* value);
  inline void set_to_key(const void* value, size_t size);
  inline ::std::string* mutable_to_key();
  inline ::std::string* release_to_key();
  
  // optional uint32 limit = 6;
  inline bool has_limit() const;
  inline void clear_limit();
  static const int kLimitFieldNumber = 6;
  inline ::google::protobuf::uint32 limit() const;
  inline void set_limit(::google::protobuf::uint32 value);
  
  // @@protoc_insertion_point(class_scope:Api.Proto.CqQuery)
 private:
  inline void set_has_view_name();
  inline void clear_has_view_name();
  inline void set_has_sequence_id();
  inline void clear_has_sequence_id();
  inline void set_has_from_key();
  inline void clear_has_from_key();
  inline void set_has_to_key();
  inline void clear_has_to_key();
  inline void set_has_limit();
  inline void clear_has_limit();
  
  ::std::string* view_name_;
  ::google::protobuf::int64 sequence_id_;
  ::google::protobuf::RepeatedPtrField< ::std::string> keys_;
  ::std::string* from_key_;
  ::std::string* to_key_;
  ::google::protobuf::uint32 limit_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];
  
  friend void  protobuf_AddDesc_proto_2fApi_2eproto();
  friend void protobuf_AssignDesc_proto_2fApi_2eproto();
  friend void protobuf_ShutdownFile_proto_2fApi_2eproto();
  
  void InitAsDefaultInstance();
  static CqQuery* default_instance_;
};
// -------------------------------------------------------------------

class CqShortTransact : public ::google::protobuf::MessageLite {
 public:
  CqShortTransact();
  virtual ~CqShortTransact();
  
  CqShortTransact(const CqShortTransact& from);
  
  inline CqShortTransact& operator=(const CqShortTransact& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const CqShortTransact& default_instance();
  
  void Swap(CqShortTransact* other);
  
  // implements Message ----------------------------------------------
  
  CqShortTransact* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CqShortTransact& from);
  void MergeFrom(const CqShortTransact& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // repeated .Api.Proto.Mutation mutations = 1;
  inline int mutations_size() const;
  inline void clear_mutations();
  static const int kMutationsFieldNumber = 1;
  inline const ::Api::Proto::Mutation& mutations(int index) const;
  inline ::Api::Proto::Mutation* mutable_mutations(int index);
  inline ::Api::Proto::Mutation* add_mutations();
  inline const ::google::protobuf::RepeatedPtrField< ::Api::Proto::Mutation >&
      mutations() const;
  inline ::google::protobuf::RepeatedPtrField< ::Api::Proto::Mutation >*
      mutable_mutations();
  
  // repeated .Api.Proto.Constraint constraints = 2;
  inline int constraints_size() const;
  inline void clear_constraints();
  static const int kConstraintsFieldNumber = 2;
  inline const ::Api::Proto::Constraint& constraints(int index) const;
  inline ::Api::Proto::Constraint* mutable_constraints(int index);
  inline ::Api::Proto::Constraint* add_constraints();
  inline const ::google::protobuf::RepeatedPtrField< ::Api::Proto::Constraint >&
      constraints() const;
  inline ::google::protobuf::RepeatedPtrField< ::Api::Proto::Constraint >*
      mutable_constraints();
  
  // @@protoc_insertion_point(class_scope:Api.Proto.CqShortTransact)
 private:
  
  ::google::protobuf::RepeatedPtrField< ::Api::Proto::Mutation > mutations_;
  ::google::protobuf::RepeatedPtrField< ::Api::Proto::Constraint > constraints_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_proto_2fApi_2eproto();
  friend void protobuf_AssignDesc_proto_2fApi_2eproto();
  friend void protobuf_ShutdownFile_proto_2fApi_2eproto();
  
  void InitAsDefaultInstance();
  static CqShortTransact* default_instance_;
};
// -------------------------------------------------------------------

class CqTransaction : public ::google::protobuf::MessageLite {
 public:
  CqTransaction();
  virtual ~CqTransaction();
  
  CqTransaction(const CqTransaction& from);
  
  inline CqTransaction& operator=(const CqTransaction& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const CqTransaction& default_instance();
  
  void Swap(CqTransaction* other);
  
  // implements Message ----------------------------------------------
  
  CqTransaction* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CqTransaction& from);
  void MergeFrom(const CqTransaction& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // @@protoc_insertion_point(class_scope:Api.Proto.CqTransaction)
 private:
  
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[1];
  
  friend void  protobuf_AddDesc_proto_2fApi_2eproto();
  friend void protobuf_AssignDesc_proto_2fApi_2eproto();
  friend void protobuf_ShutdownFile_proto_2fApi_2eproto();
  
  void InitAsDefaultInstance();
  static CqTransaction* default_instance_;
};
// -------------------------------------------------------------------

class CqUpdate : public ::google::protobuf::MessageLite {
 public:
  CqUpdate();
  virtual ~CqUpdate();
  
  CqUpdate(const CqUpdate& from);
  
  inline CqUpdate& operator=(const CqUpdate& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const CqUpdate& default_instance();
  
  void Swap(CqUpdate* other);
  
  // implements Message ----------------------------------------------
  
  CqUpdate* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CqUpdate& from);
  void MergeFrom(const CqUpdate& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional int64 transaction_id = 1;
  inline bool has_transaction_id() const;
  inline void clear_transaction_id();
  static const int kTransactionIdFieldNumber = 1;
  inline ::google::protobuf::int64 transaction_id() const;
  inline void set_transaction_id(::google::protobuf::int64 value);
  
  // repeated .Api.Proto.Mutation mutations = 2;
  inline int mutations_size() const;
  inline void clear_mutations();
  static const int kMutationsFieldNumber = 2;
  inline const ::Api::Proto::Mutation& mutations(int index) const;
  inline ::Api::Proto::Mutation* mutable_mutations(int index);
  inline ::Api::Proto::Mutation* add_mutations();
  inline const ::google::protobuf::RepeatedPtrField< ::Api::Proto::Mutation >&
      mutations() const;
  inline ::google::protobuf::RepeatedPtrField< ::Api::Proto::Mutation >*
      mutable_mutations();
  
  // repeated .Api.Proto.Constraint constraints = 3;
  inline int constraints_size() const;
  inline void clear_constraints();
  static const int kConstraintsFieldNumber = 3;
  inline const ::Api::Proto::Constraint& constraints(int index) const;
  inline ::Api::Proto::Constraint* mutable_constraints(int index);
  inline ::Api::Proto::Constraint* add_constraints();
  inline const ::google::protobuf::RepeatedPtrField< ::Api::Proto::Constraint >&
      constraints() const;
  inline ::google::protobuf::RepeatedPtrField< ::Api::Proto::Constraint >*
      mutable_constraints();
  
  // @@protoc_insertion_point(class_scope:Api.Proto.CqUpdate)
 private:
  inline void set_has_transaction_id();
  inline void clear_has_transaction_id();
  
  ::google::protobuf::int64 transaction_id_;
  ::google::protobuf::RepeatedPtrField< ::Api::Proto::Mutation > mutations_;
  ::google::protobuf::RepeatedPtrField< ::Api::Proto::Constraint > constraints_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_proto_2fApi_2eproto();
  friend void protobuf_AssignDesc_proto_2fApi_2eproto();
  friend void protobuf_ShutdownFile_proto_2fApi_2eproto();
  
  void InitAsDefaultInstance();
  static CqUpdate* default_instance_;
};
// -------------------------------------------------------------------

class CqApply : public ::google::protobuf::MessageLite {
 public:
  CqApply();
  virtual ~CqApply();
  
  CqApply(const CqApply& from);
  
  inline CqApply& operator=(const CqApply& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const CqApply& default_instance();
  
  void Swap(CqApply* other);
  
  // implements Message ----------------------------------------------
  
  CqApply* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CqApply& from);
  void MergeFrom(const CqApply& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  typedef CqApply_Type Type;
  static const Type kTypeNone = CqApply_Type_kTypeNone;
  static const Type kTypeSubmit = CqApply_Type_kTypeSubmit;
  static const Type kTypeSubmitCommit = CqApply_Type_kTypeSubmitCommit;
  static const Type kTypeCommit = CqApply_Type_kTypeCommit;
  static const Type kTypeRollback = CqApply_Type_kTypeRollback;
  static inline bool Type_IsValid(int value) {
    return CqApply_Type_IsValid(value);
  }
  static const Type Type_MIN =
    CqApply_Type_Type_MIN;
  static const Type Type_MAX =
    CqApply_Type_Type_MAX;
  static const int Type_ARRAYSIZE =
    CqApply_Type_Type_ARRAYSIZE;
  
  // accessors -------------------------------------------------------
  
  // optional int64 transaction_id = 1;
  inline bool has_transaction_id() const;
  inline void clear_transaction_id();
  static const int kTransactionIdFieldNumber = 1;
  inline ::google::protobuf::int64 transaction_id() const;
  inline void set_transaction_id(::google::protobuf::int64 value);
  
  // optional .Api.Proto.CqApply.Type type = 2;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 2;
  inline ::Api::Proto::CqApply_Type type() const;
  inline void set_type(::Api::Proto::CqApply_Type value);
  
  // @@protoc_insertion_point(class_scope:Api.Proto.CqApply)
 private:
  inline void set_has_transaction_id();
  inline void clear_has_transaction_id();
  inline void set_has_type();
  inline void clear_has_type();
  
  ::google::protobuf::int64 transaction_id_;
  int type_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_proto_2fApi_2eproto();
  friend void protobuf_AssignDesc_proto_2fApi_2eproto();
  friend void protobuf_ShutdownFile_proto_2fApi_2eproto();
  
  void InitAsDefaultInstance();
  static CqApply* default_instance_;
};
// -------------------------------------------------------------------

class CqCreateStorage : public ::google::protobuf::MessageLite {
 public:
  CqCreateStorage();
  virtual ~CqCreateStorage();
  
  CqCreateStorage(const CqCreateStorage& from);
  
  inline CqCreateStorage& operator=(const CqCreateStorage& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const CqCreateStorage& default_instance();
  
  void Swap(CqCreateStorage* other);
  
  // implements Message ----------------------------------------------
  
  CqCreateStorage* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CqCreateStorage& from);
  void MergeFrom(const CqCreateStorage& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional string driver = 1;
  inline bool has_driver() const;
  inline void clear_driver();
  static const int kDriverFieldNumber = 1;
  inline const ::std::string& driver() const;
  inline void set_driver(const ::std::string& value);
  inline void set_driver(const char* value);
  inline void set_driver(const char* value, size_t size);
  inline ::std::string* mutable_driver();
  inline ::std::string* release_driver();
  
  // optional string identifier = 2;
  inline bool has_identifier() const;
  inline void clear_identifier();
  static const int kIdentifierFieldNumber = 2;
  inline const ::std::string& identifier() const;
  inline void set_identifier(const ::std::string& value);
  inline void set_identifier(const char* value);
  inline void set_identifier(const char* value, size_t size);
  inline ::std::string* mutable_identifier();
  inline ::std::string* release_identifier();
  
  // optional .Db.Proto.StorageConfig config = 3;
  inline bool has_config() const;
  inline void clear_config();
  static const int kConfigFieldNumber = 3;
  inline const ::Db::Proto::StorageConfig& config() const;
  inline ::Db::Proto::StorageConfig* mutable_config();
  inline ::Db::Proto::StorageConfig* release_config();
  
  // @@protoc_insertion_point(class_scope:Api.Proto.CqCreateStorage)
 private:
  inline void set_has_driver();
  inline void clear_has_driver();
  inline void set_has_identifier();
  inline void clear_has_identifier();
  inline void set_has_config();
  inline void clear_has_config();
  
  ::std::string* driver_;
  ::std::string* identifier_;
  ::Db::Proto::StorageConfig* config_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_proto_2fApi_2eproto();
  friend void protobuf_AssignDesc_proto_2fApi_2eproto();
  friend void protobuf_ShutdownFile_proto_2fApi_2eproto();
  
  void InitAsDefaultInstance();
  static CqCreateStorage* default_instance_;
};
// -------------------------------------------------------------------

class CqCreateView : public ::google::protobuf::MessageLite {
 public:
  CqCreateView();
  virtual ~CqCreateView();
  
  CqCreateView(const CqCreateView& from);
  
  inline CqCreateView& operator=(const CqCreateView& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const CqCreateView& default_instance();
  
  void Swap(CqCreateView* other);
  
  // implements Message ----------------------------------------------
  
  CqCreateView* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CqCreateView& from);
  void MergeFrom(const CqCreateView& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional string driver = 1;
  inline bool has_driver() const;
  inline void clear_driver();
  static const int kDriverFieldNumber = 1;
  inline const ::std::string& driver() const;
  inline void set_driver(const ::std::string& value);
  inline void set_driver(const char* value);
  inline void set_driver(const char* value, size_t size);
  inline ::std::string* mutable_driver();
  inline ::std::string* release_driver();
  
  // optional string identifier = 2;
  inline bool has_identifier() const;
  inline void clear_identifier();
  static const int kIdentifierFieldNumber = 2;
  inline const ::std::string& identifier() const;
  inline void set_identifier(const ::std::string& value);
  inline void set_identifier(const char* value);
  inline void set_identifier(const char* value, size_t size);
  inline ::std::string* mutable_identifier();
  inline ::std::string* release_identifier();
  
  // optional .Db.Proto.ViewConfig config = 3;
  inline bool has_config() const;
  inline void clear_config();
  static const int kConfigFieldNumber = 3;
  inline const ::Db::Proto::ViewConfig& config() const;
  inline ::Db::Proto::ViewConfig* mutable_config();
  inline ::Db::Proto::ViewConfig* release_config();
  
  // @@protoc_insertion_point(class_scope:Api.Proto.CqCreateView)
 private:
  inline void set_has_driver();
  inline void clear_has_driver();
  inline void set_has_identifier();
  inline void clear_has_identifier();
  inline void set_has_config();
  inline void clear_has_config();
  
  ::std::string* driver_;
  ::std::string* identifier_;
  ::Db::Proto::ViewConfig* config_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_proto_2fApi_2eproto();
  friend void protobuf_AssignDesc_proto_2fApi_2eproto();
  friend void protobuf_ShutdownFile_proto_2fApi_2eproto();
  
  void InitAsDefaultInstance();
  static CqCreateView* default_instance_;
};
// -------------------------------------------------------------------

class CqUnlinkStorage : public ::google::protobuf::MessageLite {
 public:
  CqUnlinkStorage();
  virtual ~CqUnlinkStorage();
  
  CqUnlinkStorage(const CqUnlinkStorage& from);
  
  inline CqUnlinkStorage& operator=(const CqUnlinkStorage& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const CqUnlinkStorage& default_instance();
  
  void Swap(CqUnlinkStorage* other);
  
  // implements Message ----------------------------------------------
  
  CqUnlinkStorage* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CqUnlinkStorage& from);
  void MergeFrom(const CqUnlinkStorage& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string identifier = 1;
  inline bool has_identifier() const;
  inline void clear_identifier();
  static const int kIdentifierFieldNumber = 1;
  inline const ::std::string& identifier() const;
  inline void set_identifier(const ::std::string& value);
  inline void set_identifier(const char* value);
  inline void set_identifier(const char* value, size_t size);
  inline ::std::string* mutable_identifier();
  inline ::std::string* release_identifier();
  
  // @@protoc_insertion_point(class_scope:Api.Proto.CqUnlinkStorage)
 private:
  inline void set_has_identifier();
  inline void clear_has_identifier();
  
  ::std::string* identifier_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_proto_2fApi_2eproto();
  friend void protobuf_AssignDesc_proto_2fApi_2eproto();
  friend void protobuf_ShutdownFile_proto_2fApi_2eproto();
  
  void InitAsDefaultInstance();
  static CqUnlinkStorage* default_instance_;
};
// -------------------------------------------------------------------

class CqUnlinkView : public ::google::protobuf::MessageLite {
 public:
  CqUnlinkView();
  virtual ~CqUnlinkView();
  
  CqUnlinkView(const CqUnlinkView& from);
  
  inline CqUnlinkView& operator=(const CqUnlinkView& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const CqUnlinkView& default_instance();
  
  void Swap(CqUnlinkView* other);
  
  // implements Message ----------------------------------------------
  
  CqUnlinkView* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CqUnlinkView& from);
  void MergeFrom(const CqUnlinkView& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string identifier = 1;
  inline bool has_identifier() const;
  inline void clear_identifier();
  static const int kIdentifierFieldNumber = 1;
  inline const ::std::string& identifier() const;
  inline void set_identifier(const ::std::string& value);
  inline void set_identifier(const char* value);
  inline void set_identifier(const char* value, size_t size);
  inline ::std::string* mutable_identifier();
  inline ::std::string* release_identifier();
  
  // @@protoc_insertion_point(class_scope:Api.Proto.CqUnlinkView)
 private:
  inline void set_has_identifier();
  inline void clear_has_identifier();
  
  ::std::string* identifier_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_proto_2fApi_2eproto();
  friend void protobuf_AssignDesc_proto_2fApi_2eproto();
  friend void protobuf_ShutdownFile_proto_2fApi_2eproto();
  
  void InitAsDefaultInstance();
  static CqUnlinkView* default_instance_;
};
// -------------------------------------------------------------------

class CqUploadExtern : public ::google::protobuf::MessageLite {
 public:
  CqUploadExtern();
  virtual ~CqUploadExtern();
  
  CqUploadExtern(const CqUploadExtern& from);
  
  inline CqUploadExtern& operator=(const CqUploadExtern& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const CqUploadExtern& default_instance();
  
  void Swap(CqUploadExtern* other);
  
  // implements Message ----------------------------------------------
  
  CqUploadExtern* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CqUploadExtern& from);
  void MergeFrom(const CqUploadExtern& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string file_name = 1;
  inline bool has_file_name() const;
  inline void clear_file_name();
  static const int kFileNameFieldNumber = 1;
  inline const ::std::string& file_name() const;
  inline void set_file_name(const ::std::string& value);
  inline void set_file_name(const char* value);
  inline void set_file_name(const char* value, size_t size);
  inline ::std::string* mutable_file_name();
  inline ::std::string* release_file_name();
  
  // required bytes buffer = 2;
  inline bool has_buffer() const;
  inline void clear_buffer();
  static const int kBufferFieldNumber = 2;
  inline const ::std::string& buffer() const;
  inline void set_buffer(const ::std::string& value);
  inline void set_buffer(const char* value);
  inline void set_buffer(const void* value, size_t size);
  inline ::std::string* mutable_buffer();
  inline ::std::string* release_buffer();
  
  // @@protoc_insertion_point(class_scope:Api.Proto.CqUploadExtern)
 private:
  inline void set_has_file_name();
  inline void clear_has_file_name();
  inline void set_has_buffer();
  inline void clear_has_buffer();
  
  ::std::string* file_name_;
  ::std::string* buffer_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_proto_2fApi_2eproto();
  friend void protobuf_AssignDesc_proto_2fApi_2eproto();
  friend void protobuf_ShutdownFile_proto_2fApi_2eproto();
  
  void InitAsDefaultInstance();
  static CqUploadExtern* default_instance_;
};
// -------------------------------------------------------------------

class CqDownloadExtern : public ::google::protobuf::MessageLite {
 public:
  CqDownloadExtern();
  virtual ~CqDownloadExtern();
  
  CqDownloadExtern(const CqDownloadExtern& from);
  
  inline CqDownloadExtern& operator=(const CqDownloadExtern& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const CqDownloadExtern& default_instance();
  
  void Swap(CqDownloadExtern* other);
  
  // implements Message ----------------------------------------------
  
  CqDownloadExtern* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CqDownloadExtern& from);
  void MergeFrom(const CqDownloadExtern& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string file_name = 1;
  inline bool has_file_name() const;
  inline void clear_file_name();
  static const int kFileNameFieldNumber = 1;
  inline const ::std::string& file_name() const;
  inline void set_file_name(const ::std::string& value);
  inline void set_file_name(const char* value);
  inline void set_file_name(const char* value, size_t size);
  inline ::std::string* mutable_file_name();
  inline ::std::string* release_file_name();
  
  // @@protoc_insertion_point(class_scope:Api.Proto.CqDownloadExtern)
 private:
  inline void set_has_file_name();
  inline void clear_has_file_name();
  
  ::std::string* file_name_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_proto_2fApi_2eproto();
  friend void protobuf_AssignDesc_proto_2fApi_2eproto();
  friend void protobuf_ShutdownFile_proto_2fApi_2eproto();
  
  void InitAsDefaultInstance();
  static CqDownloadExtern* default_instance_;
};
// -------------------------------------------------------------------

class CqShutdown : public ::google::protobuf::MessageLite {
 public:
  CqShutdown();
  virtual ~CqShutdown();
  
  CqShutdown(const CqShutdown& from);
  
  inline CqShutdown& operator=(const CqShutdown& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const CqShutdown& default_instance();
  
  void Swap(CqShutdown* other);
  
  // implements Message ----------------------------------------------
  
  CqShutdown* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CqShutdown& from);
  void MergeFrom(const CqShutdown& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // @@protoc_insertion_point(class_scope:Api.Proto.CqShutdown)
 private:
  
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[1];
  
  friend void  protobuf_AddDesc_proto_2fApi_2eproto();
  friend void protobuf_AssignDesc_proto_2fApi_2eproto();
  friend void protobuf_ShutdownFile_proto_2fApi_2eproto();
  
  void InitAsDefaultInstance();
  static CqShutdown* default_instance_;
};
// -------------------------------------------------------------------

class SrFin_MutationInfo : public ::google::protobuf::MessageLite {
 public:
  SrFin_MutationInfo();
  virtual ~SrFin_MutationInfo();
  
  SrFin_MutationInfo(const SrFin_MutationInfo& from);
  
  inline SrFin_MutationInfo& operator=(const SrFin_MutationInfo& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const SrFin_MutationInfo& default_instance();
  
  void Swap(SrFin_MutationInfo* other);
  
  // implements Message ----------------------------------------------
  
  SrFin_MutationInfo* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const SrFin_MutationInfo& from);
  void MergeFrom(const SrFin_MutationInfo& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional int64 document_id = 1;
  inline bool has_document_id() const;
  inline void clear_document_id();
  static const int kDocumentIdFieldNumber = 1;
  inline ::google::protobuf::int64 document_id() const;
  inline void set_document_id(::google::protobuf::int64 value);
  
  // @@protoc_insertion_point(class_scope:Api.Proto.SrFin.MutationInfo)
 private:
  inline void set_has_document_id();
  inline void clear_has_document_id();
  
  ::google::protobuf::int64 document_id_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_proto_2fApi_2eproto();
  friend void protobuf_AssignDesc_proto_2fApi_2eproto();
  friend void protobuf_ShutdownFile_proto_2fApi_2eproto();
  
  void InitAsDefaultInstance();
  static SrFin_MutationInfo* default_instance_;
};
// -------------------------------------------------------------------

class SrFin : public ::google::protobuf::MessageLite {
 public:
  SrFin();
  virtual ~SrFin();
  
  SrFin(const SrFin& from);
  
  inline SrFin& operator=(const SrFin& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const SrFin& default_instance();
  
  void Swap(SrFin* other);
  
  // implements Message ----------------------------------------------
  
  SrFin* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const SrFin& from);
  void MergeFrom(const SrFin& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  typedef SrFin_MutationInfo MutationInfo;
  
  // accessors -------------------------------------------------------
  
  // optional .Api.Proto.ErrorCode error = 1;
  inline bool has_error() const;
  inline void clear_error();
  static const int kErrorFieldNumber = 1;
  inline Api::Proto::ErrorCode error() const;
  inline void set_error(Api::Proto::ErrorCode value);
  
  // optional int64 transaction_id = 2;
  inline bool has_transaction_id() const;
  inline void clear_transaction_id();
  static const int kTransactionIdFieldNumber = 2;
  inline ::google::protobuf::int64 transaction_id() const;
  inline void set_transaction_id(::google::protobuf::int64 value);
  
  // optional int64 sequence_id = 3;
  inline bool has_sequence_id() const;
  inline void clear_sequence_id();
  static const int kSequenceIdFieldNumber = 3;
  inline ::google::protobuf::int64 sequence_id() const;
  inline void set_sequence_id(::google::protobuf::int64 value);
  
  // repeated .Api.Proto.SrFin.MutationInfo mutations = 4;
  inline int mutations_size() const;
  inline void clear_mutations();
  static const int kMutationsFieldNumber = 4;
  inline const ::Api::Proto::SrFin_MutationInfo& mutations(int index) const;
  inline ::Api::Proto::SrFin_MutationInfo* mutable_mutations(int index);
  inline ::Api::Proto::SrFin_MutationInfo* add_mutations();
  inline const ::google::protobuf::RepeatedPtrField< ::Api::Proto::SrFin_MutationInfo >&
      mutations() const;
  inline ::google::protobuf::RepeatedPtrField< ::Api::Proto::SrFin_MutationInfo >*
      mutable_mutations();
  
  // @@protoc_insertion_point(class_scope:Api.Proto.SrFin)
 private:
  inline void set_has_error();
  inline void clear_has_error();
  inline void set_has_transaction_id();
  inline void clear_has_transaction_id();
  inline void set_has_sequence_id();
  inline void clear_has_sequence_id();
  
  ::google::protobuf::int64 transaction_id_;
  ::google::protobuf::int64 sequence_id_;
  ::google::protobuf::RepeatedPtrField< ::Api::Proto::SrFin_MutationInfo > mutations_;
  int error_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];
  
  friend void  protobuf_AddDesc_proto_2fApi_2eproto();
  friend void protobuf_AssignDesc_proto_2fApi_2eproto();
  friend void protobuf_ShutdownFile_proto_2fApi_2eproto();
  
  void InitAsDefaultInstance();
  static SrFin* default_instance_;
};
// -------------------------------------------------------------------

class SrRows : public ::google::protobuf::MessageLite {
 public:
  SrRows();
  virtual ~SrRows();
  
  SrRows(const SrRows& from);
  
  inline SrRows& operator=(const SrRows& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const SrRows& default_instance();
  
  void Swap(SrRows* other);
  
  // implements Message ----------------------------------------------
  
  SrRows* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const SrRows& from);
  void MergeFrom(const SrRows& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // repeated bytes row_data = 1;
  inline int row_data_size() const;
  inline void clear_row_data();
  static const int kRowDataFieldNumber = 1;
  inline const ::std::string& row_data(int index) const;
  inline ::std::string* mutable_row_data(int index);
  inline void set_row_data(int index, const ::std::string& value);
  inline void set_row_data(int index, const char* value);
  inline void set_row_data(int index, const void* value, size_t size);
  inline ::std::string* add_row_data();
  inline void add_row_data(const ::std::string& value);
  inline void add_row_data(const char* value);
  inline void add_row_data(const void* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& row_data() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_row_data();
  
  // @@protoc_insertion_point(class_scope:Api.Proto.SrRows)
 private:
  
  ::google::protobuf::RepeatedPtrField< ::std::string> row_data_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_proto_2fApi_2eproto();
  friend void protobuf_AssignDesc_proto_2fApi_2eproto();
  friend void protobuf_ShutdownFile_proto_2fApi_2eproto();
  
  void InitAsDefaultInstance();
  static SrRows* default_instance_;
};
// -------------------------------------------------------------------

class SrBlob : public ::google::protobuf::MessageLite {
 public:
  SrBlob();
  virtual ~SrBlob();
  
  SrBlob(const SrBlob& from);
  
  inline SrBlob& operator=(const SrBlob& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const SrBlob& default_instance();
  
  void Swap(SrBlob* other);
  
  // implements Message ----------------------------------------------
  
  SrBlob* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const SrBlob& from);
  void MergeFrom(const SrBlob& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required bytes buffer = 1;
  inline bool has_buffer() const;
  inline void clear_buffer();
  static const int kBufferFieldNumber = 1;
  inline const ::std::string& buffer() const;
  inline void set_buffer(const ::std::string& value);
  inline void set_buffer(const char* value);
  inline void set_buffer(const void* value, size_t size);
  inline ::std::string* mutable_buffer();
  inline ::std::string* release_buffer();
  
  // @@protoc_insertion_point(class_scope:Api.Proto.SrBlob)
 private:
  inline void set_has_buffer();
  inline void clear_has_buffer();
  
  ::std::string* buffer_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_proto_2fApi_2eproto();
  friend void protobuf_AssignDesc_proto_2fApi_2eproto();
  friend void protobuf_ShutdownFile_proto_2fApi_2eproto();
  
  void InitAsDefaultInstance();
  static SrBlob* default_instance_;
};
// ===================================================================


// ===================================================================

// Mutation

// optional .Api.Proto.Mutation.Type type = 1;
inline bool Mutation::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Mutation::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Mutation::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Mutation::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::Api::Proto::Mutation_Type Mutation::type() const {
  return static_cast< ::Api::Proto::Mutation_Type >(type_);
}
inline void Mutation::set_type(::Api::Proto::Mutation_Type value) {
  GOOGLE_DCHECK(::Api::Proto::Mutation_Type_IsValid(value));
  set_has_type();
  type_ = value;
}

// optional int64 document_id = 2;
inline bool Mutation::has_document_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Mutation::set_has_document_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Mutation::clear_has_document_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Mutation::clear_document_id() {
  document_id_ = GOOGLE_LONGLONG(0);
  clear_has_document_id();
}
inline ::google::protobuf::int64 Mutation::document_id() const {
  return document_id_;
}
inline void Mutation::set_document_id(::google::protobuf::int64 value) {
  set_has_document_id();
  document_id_ = value;
}

// optional string storage_name = 3;
inline bool Mutation::has_storage_name() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Mutation::set_has_storage_name() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Mutation::clear_has_storage_name() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Mutation::clear_storage_name() {
  if (storage_name_ != &::google::protobuf::internal::kEmptyString) {
    storage_name_->clear();
  }
  clear_has_storage_name();
}
inline const ::std::string& Mutation::storage_name() const {
  return *storage_name_;
}
inline void Mutation::set_storage_name(const ::std::string& value) {
  set_has_storage_name();
  if (storage_name_ == &::google::protobuf::internal::kEmptyString) {
    storage_name_ = new ::std::string;
  }
  storage_name_->assign(value);
}
inline void Mutation::set_storage_name(const char* value) {
  set_has_storage_name();
  if (storage_name_ == &::google::protobuf::internal::kEmptyString) {
    storage_name_ = new ::std::string;
  }
  storage_name_->assign(value);
}
inline void Mutation::set_storage_name(const char* value, size_t size) {
  set_has_storage_name();
  if (storage_name_ == &::google::protobuf::internal::kEmptyString) {
    storage_name_ = new ::std::string;
  }
  storage_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Mutation::mutable_storage_name() {
  set_has_storage_name();
  if (storage_name_ == &::google::protobuf::internal::kEmptyString) {
    storage_name_ = new ::std::string;
  }
  return storage_name_;
}
inline ::std::string* Mutation::release_storage_name() {
  clear_has_storage_name();
  if (storage_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = storage_name_;
    storage_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional bytes buffer = 4;
inline bool Mutation::has_buffer() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Mutation::set_has_buffer() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Mutation::clear_has_buffer() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Mutation::clear_buffer() {
  if (buffer_ != &::google::protobuf::internal::kEmptyString) {
    buffer_->clear();
  }
  clear_has_buffer();
}
inline const ::std::string& Mutation::buffer() const {
  return *buffer_;
}
inline void Mutation::set_buffer(const ::std::string& value) {
  set_has_buffer();
  if (buffer_ == &::google::protobuf::internal::kEmptyString) {
    buffer_ = new ::std::string;
  }
  buffer_->assign(value);
}
inline void Mutation::set_buffer(const char* value) {
  set_has_buffer();
  if (buffer_ == &::google::protobuf::internal::kEmptyString) {
    buffer_ = new ::std::string;
  }
  buffer_->assign(value);
}
inline void Mutation::set_buffer(const void* value, size_t size) {
  set_has_buffer();
  if (buffer_ == &::google::protobuf::internal::kEmptyString) {
    buffer_ = new ::std::string;
  }
  buffer_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Mutation::mutable_buffer() {
  set_has_buffer();
  if (buffer_ == &::google::protobuf::internal::kEmptyString) {
    buffer_ = new ::std::string;
  }
  return buffer_;
}
inline ::std::string* Mutation::release_buffer() {
  clear_has_buffer();
  if (buffer_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = buffer_;
    buffer_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// Constraint

// optional .Api.Proto.Constraint.Type type = 1;
inline bool Constraint::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Constraint::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Constraint::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Constraint::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::Api::Proto::Constraint_Type Constraint::type() const {
  return static_cast< ::Api::Proto::Constraint_Type >(type_);
}
inline void Constraint::set_type(::Api::Proto::Constraint_Type value) {
  GOOGLE_DCHECK(::Api::Proto::Constraint_Type_IsValid(value));
  set_has_type();
  type_ = value;
}

// optional string storage_name = 2;
inline bool Constraint::has_storage_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Constraint::set_has_storage_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Constraint::clear_has_storage_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Constraint::clear_storage_name() {
  if (storage_name_ != &::google::protobuf::internal::kEmptyString) {
    storage_name_->clear();
  }
  clear_has_storage_name();
}
inline const ::std::string& Constraint::storage_name() const {
  return *storage_name_;
}
inline void Constraint::set_storage_name(const ::std::string& value) {
  set_has_storage_name();
  if (storage_name_ == &::google::protobuf::internal::kEmptyString) {
    storage_name_ = new ::std::string;
  }
  storage_name_->assign(value);
}
inline void Constraint::set_storage_name(const char* value) {
  set_has_storage_name();
  if (storage_name_ == &::google::protobuf::internal::kEmptyString) {
    storage_name_ = new ::std::string;
  }
  storage_name_->assign(value);
}
inline void Constraint::set_storage_name(const char* value, size_t size) {
  set_has_storage_name();
  if (storage_name_ == &::google::protobuf::internal::kEmptyString) {
    storage_name_ = new ::std::string;
  }
  storage_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Constraint::mutable_storage_name() {
  set_has_storage_name();
  if (storage_name_ == &::google::protobuf::internal::kEmptyString) {
    storage_name_ = new ::std::string;
  }
  return storage_name_;
}
inline ::std::string* Constraint::release_storage_name() {
  clear_has_storage_name();
  if (storage_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = storage_name_;
    storage_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional int64 document_id = 3;
inline bool Constraint::has_document_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Constraint::set_has_document_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Constraint::clear_has_document_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Constraint::clear_document_id() {
  document_id_ = GOOGLE_LONGLONG(0);
  clear_has_document_id();
}
inline ::google::protobuf::int64 Constraint::document_id() const {
  return document_id_;
}
inline void Constraint::set_document_id(::google::protobuf::int64 value) {
  set_has_document_id();
  document_id_ = value;
}

// optional int64 sequence_id = 4;
inline bool Constraint::has_sequence_id() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Constraint::set_has_sequence_id() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Constraint::clear_has_sequence_id() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Constraint::clear_sequence_id() {
  sequence_id_ = GOOGLE_LONGLONG(0);
  clear_has_sequence_id();
}
inline ::google::protobuf::int64 Constraint::sequence_id() const {
  return sequence_id_;
}
inline void Constraint::set_sequence_id(::google::protobuf::int64 value) {
  set_has_sequence_id();
  sequence_id_ = value;
}

// optional bool must_exist = 5;
inline bool Constraint::has_must_exist() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Constraint::set_has_must_exist() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Constraint::clear_has_must_exist() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Constraint::clear_must_exist() {
  must_exist_ = false;
  clear_has_must_exist();
}
inline bool Constraint::must_exist() const {
  return must_exist_;
}
inline void Constraint::set_must_exist(bool value) {
  set_has_must_exist();
  must_exist_ = value;
}

// optional bool match_sequence_id = 6;
inline bool Constraint::has_match_sequence_id() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Constraint::set_has_match_sequence_id() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Constraint::clear_has_match_sequence_id() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Constraint::clear_match_sequence_id() {
  match_sequence_id_ = false;
  clear_has_match_sequence_id();
}
inline bool Constraint::match_sequence_id() const {
  return match_sequence_id_;
}
inline void Constraint::set_match_sequence_id(bool value) {
  set_has_match_sequence_id();
  match_sequence_id_ = value;
}

// -------------------------------------------------------------------

// CqQuery

// optional string view_name = 1;
inline bool CqQuery::has_view_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CqQuery::set_has_view_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CqQuery::clear_has_view_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CqQuery::clear_view_name() {
  if (view_name_ != &::google::protobuf::internal::kEmptyString) {
    view_name_->clear();
  }
  clear_has_view_name();
}
inline const ::std::string& CqQuery::view_name() const {
  return *view_name_;
}
inline void CqQuery::set_view_name(const ::std::string& value) {
  set_has_view_name();
  if (view_name_ == &::google::protobuf::internal::kEmptyString) {
    view_name_ = new ::std::string;
  }
  view_name_->assign(value);
}
inline void CqQuery::set_view_name(const char* value) {
  set_has_view_name();
  if (view_name_ == &::google::protobuf::internal::kEmptyString) {
    view_name_ = new ::std::string;
  }
  view_name_->assign(value);
}
inline void CqQuery::set_view_name(const char* value, size_t size) {
  set_has_view_name();
  if (view_name_ == &::google::protobuf::internal::kEmptyString) {
    view_name_ = new ::std::string;
  }
  view_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CqQuery::mutable_view_name() {
  set_has_view_name();
  if (view_name_ == &::google::protobuf::internal::kEmptyString) {
    view_name_ = new ::std::string;
  }
  return view_name_;
}
inline ::std::string* CqQuery::release_view_name() {
  clear_has_view_name();
  if (view_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = view_name_;
    view_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional int64 sequence_id = 2;
inline bool CqQuery::has_sequence_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CqQuery::set_has_sequence_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CqQuery::clear_has_sequence_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CqQuery::clear_sequence_id() {
  sequence_id_ = GOOGLE_LONGLONG(0);
  clear_has_sequence_id();
}
inline ::google::protobuf::int64 CqQuery::sequence_id() const {
  return sequence_id_;
}
inline void CqQuery::set_sequence_id(::google::protobuf::int64 value) {
  set_has_sequence_id();
  sequence_id_ = value;
}

// repeated bytes keys = 3;
inline int CqQuery::keys_size() const {
  return keys_.size();
}
inline void CqQuery::clear_keys() {
  keys_.Clear();
}
inline const ::std::string& CqQuery::keys(int index) const {
  return keys_.Get(index);
}
inline ::std::string* CqQuery::mutable_keys(int index) {
  return keys_.Mutable(index);
}
inline void CqQuery::set_keys(int index, const ::std::string& value) {
  keys_.Mutable(index)->assign(value);
}
inline void CqQuery::set_keys(int index, const char* value) {
  keys_.Mutable(index)->assign(value);
}
inline void CqQuery::set_keys(int index, const void* value, size_t size) {
  keys_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CqQuery::add_keys() {
  return keys_.Add();
}
inline void CqQuery::add_keys(const ::std::string& value) {
  keys_.Add()->assign(value);
}
inline void CqQuery::add_keys(const char* value) {
  keys_.Add()->assign(value);
}
inline void CqQuery::add_keys(const void* value, size_t size) {
  keys_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
CqQuery::keys() const {
  return keys_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
CqQuery::mutable_keys() {
  return &keys_;
}

// optional bytes from_key = 4;
inline bool CqQuery::has_from_key() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CqQuery::set_has_from_key() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CqQuery::clear_has_from_key() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CqQuery::clear_from_key() {
  if (from_key_ != &::google::protobuf::internal::kEmptyString) {
    from_key_->clear();
  }
  clear_has_from_key();
}
inline const ::std::string& CqQuery::from_key() const {
  return *from_key_;
}
inline void CqQuery::set_from_key(const ::std::string& value) {
  set_has_from_key();
  if (from_key_ == &::google::protobuf::internal::kEmptyString) {
    from_key_ = new ::std::string;
  }
  from_key_->assign(value);
}
inline void CqQuery::set_from_key(const char* value) {
  set_has_from_key();
  if (from_key_ == &::google::protobuf::internal::kEmptyString) {
    from_key_ = new ::std::string;
  }
  from_key_->assign(value);
}
inline void CqQuery::set_from_key(const void* value, size_t size) {
  set_has_from_key();
  if (from_key_ == &::google::protobuf::internal::kEmptyString) {
    from_key_ = new ::std::string;
  }
  from_key_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CqQuery::mutable_from_key() {
  set_has_from_key();
  if (from_key_ == &::google::protobuf::internal::kEmptyString) {
    from_key_ = new ::std::string;
  }
  return from_key_;
}
inline ::std::string* CqQuery::release_from_key() {
  clear_has_from_key();
  if (from_key_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = from_key_;
    from_key_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional bytes to_key = 5;
inline bool CqQuery::has_to_key() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CqQuery::set_has_to_key() {
  _has_bits_[0] |= 0x00000010u;
}
inline void CqQuery::clear_has_to_key() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void CqQuery::clear_to_key() {
  if (to_key_ != &::google::protobuf::internal::kEmptyString) {
    to_key_->clear();
  }
  clear_has_to_key();
}
inline const ::std::string& CqQuery::to_key() const {
  return *to_key_;
}
inline void CqQuery::set_to_key(const ::std::string& value) {
  set_has_to_key();
  if (to_key_ == &::google::protobuf::internal::kEmptyString) {
    to_key_ = new ::std::string;
  }
  to_key_->assign(value);
}
inline void CqQuery::set_to_key(const char* value) {
  set_has_to_key();
  if (to_key_ == &::google::protobuf::internal::kEmptyString) {
    to_key_ = new ::std::string;
  }
  to_key_->assign(value);
}
inline void CqQuery::set_to_key(const void* value, size_t size) {
  set_has_to_key();
  if (to_key_ == &::google::protobuf::internal::kEmptyString) {
    to_key_ = new ::std::string;
  }
  to_key_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CqQuery::mutable_to_key() {
  set_has_to_key();
  if (to_key_ == &::google::protobuf::internal::kEmptyString) {
    to_key_ = new ::std::string;
  }
  return to_key_;
}
inline ::std::string* CqQuery::release_to_key() {
  clear_has_to_key();
  if (to_key_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = to_key_;
    to_key_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional uint32 limit = 6;
inline bool CqQuery::has_limit() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void CqQuery::set_has_limit() {
  _has_bits_[0] |= 0x00000020u;
}
inline void CqQuery::clear_has_limit() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void CqQuery::clear_limit() {
  limit_ = 0u;
  clear_has_limit();
}
inline ::google::protobuf::uint32 CqQuery::limit() const {
  return limit_;
}
inline void CqQuery::set_limit(::google::protobuf::uint32 value) {
  set_has_limit();
  limit_ = value;
}

// -------------------------------------------------------------------

// CqShortTransact

// repeated .Api.Proto.Mutation mutations = 1;
inline int CqShortTransact::mutations_size() const {
  return mutations_.size();
}
inline void CqShortTransact::clear_mutations() {
  mutations_.Clear();
}
inline const ::Api::Proto::Mutation& CqShortTransact::mutations(int index) const {
  return mutations_.Get(index);
}
inline ::Api::Proto::Mutation* CqShortTransact::mutable_mutations(int index) {
  return mutations_.Mutable(index);
}
inline ::Api::Proto::Mutation* CqShortTransact::add_mutations() {
  return mutations_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Api::Proto::Mutation >&
CqShortTransact::mutations() const {
  return mutations_;
}
inline ::google::protobuf::RepeatedPtrField< ::Api::Proto::Mutation >*
CqShortTransact::mutable_mutations() {
  return &mutations_;
}

// repeated .Api.Proto.Constraint constraints = 2;
inline int CqShortTransact::constraints_size() const {
  return constraints_.size();
}
inline void CqShortTransact::clear_constraints() {
  constraints_.Clear();
}
inline const ::Api::Proto::Constraint& CqShortTransact::constraints(int index) const {
  return constraints_.Get(index);
}
inline ::Api::Proto::Constraint* CqShortTransact::mutable_constraints(int index) {
  return constraints_.Mutable(index);
}
inline ::Api::Proto::Constraint* CqShortTransact::add_constraints() {
  return constraints_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Api::Proto::Constraint >&
CqShortTransact::constraints() const {
  return constraints_;
}
inline ::google::protobuf::RepeatedPtrField< ::Api::Proto::Constraint >*
CqShortTransact::mutable_constraints() {
  return &constraints_;
}

// -------------------------------------------------------------------

// CqTransaction

// -------------------------------------------------------------------

// CqUpdate

// optional int64 transaction_id = 1;
inline bool CqUpdate::has_transaction_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CqUpdate::set_has_transaction_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CqUpdate::clear_has_transaction_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CqUpdate::clear_transaction_id() {
  transaction_id_ = GOOGLE_LONGLONG(0);
  clear_has_transaction_id();
}
inline ::google::protobuf::int64 CqUpdate::transaction_id() const {
  return transaction_id_;
}
inline void CqUpdate::set_transaction_id(::google::protobuf::int64 value) {
  set_has_transaction_id();
  transaction_id_ = value;
}

// repeated .Api.Proto.Mutation mutations = 2;
inline int CqUpdate::mutations_size() const {
  return mutations_.size();
}
inline void CqUpdate::clear_mutations() {
  mutations_.Clear();
}
inline const ::Api::Proto::Mutation& CqUpdate::mutations(int index) const {
  return mutations_.Get(index);
}
inline ::Api::Proto::Mutation* CqUpdate::mutable_mutations(int index) {
  return mutations_.Mutable(index);
}
inline ::Api::Proto::Mutation* CqUpdate::add_mutations() {
  return mutations_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Api::Proto::Mutation >&
CqUpdate::mutations() const {
  return mutations_;
}
inline ::google::protobuf::RepeatedPtrField< ::Api::Proto::Mutation >*
CqUpdate::mutable_mutations() {
  return &mutations_;
}

// repeated .Api.Proto.Constraint constraints = 3;
inline int CqUpdate::constraints_size() const {
  return constraints_.size();
}
inline void CqUpdate::clear_constraints() {
  constraints_.Clear();
}
inline const ::Api::Proto::Constraint& CqUpdate::constraints(int index) const {
  return constraints_.Get(index);
}
inline ::Api::Proto::Constraint* CqUpdate::mutable_constraints(int index) {
  return constraints_.Mutable(index);
}
inline ::Api::Proto::Constraint* CqUpdate::add_constraints() {
  return constraints_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Api::Proto::Constraint >&
CqUpdate::constraints() const {
  return constraints_;
}
inline ::google::protobuf::RepeatedPtrField< ::Api::Proto::Constraint >*
CqUpdate::mutable_constraints() {
  return &constraints_;
}

// -------------------------------------------------------------------

// CqApply

// optional int64 transaction_id = 1;
inline bool CqApply::has_transaction_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CqApply::set_has_transaction_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CqApply::clear_has_transaction_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CqApply::clear_transaction_id() {
  transaction_id_ = GOOGLE_LONGLONG(0);
  clear_has_transaction_id();
}
inline ::google::protobuf::int64 CqApply::transaction_id() const {
  return transaction_id_;
}
inline void CqApply::set_transaction_id(::google::protobuf::int64 value) {
  set_has_transaction_id();
  transaction_id_ = value;
}

// optional .Api.Proto.CqApply.Type type = 2;
inline bool CqApply::has_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CqApply::set_has_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CqApply::clear_has_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CqApply::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::Api::Proto::CqApply_Type CqApply::type() const {
  return static_cast< ::Api::Proto::CqApply_Type >(type_);
}
inline void CqApply::set_type(::Api::Proto::CqApply_Type value) {
  GOOGLE_DCHECK(::Api::Proto::CqApply_Type_IsValid(value));
  set_has_type();
  type_ = value;
}

// -------------------------------------------------------------------

// CqCreateStorage

// optional string driver = 1;
inline bool CqCreateStorage::has_driver() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CqCreateStorage::set_has_driver() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CqCreateStorage::clear_has_driver() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CqCreateStorage::clear_driver() {
  if (driver_ != &::google::protobuf::internal::kEmptyString) {
    driver_->clear();
  }
  clear_has_driver();
}
inline const ::std::string& CqCreateStorage::driver() const {
  return *driver_;
}
inline void CqCreateStorage::set_driver(const ::std::string& value) {
  set_has_driver();
  if (driver_ == &::google::protobuf::internal::kEmptyString) {
    driver_ = new ::std::string;
  }
  driver_->assign(value);
}
inline void CqCreateStorage::set_driver(const char* value) {
  set_has_driver();
  if (driver_ == &::google::protobuf::internal::kEmptyString) {
    driver_ = new ::std::string;
  }
  driver_->assign(value);
}
inline void CqCreateStorage::set_driver(const char* value, size_t size) {
  set_has_driver();
  if (driver_ == &::google::protobuf::internal::kEmptyString) {
    driver_ = new ::std::string;
  }
  driver_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CqCreateStorage::mutable_driver() {
  set_has_driver();
  if (driver_ == &::google::protobuf::internal::kEmptyString) {
    driver_ = new ::std::string;
  }
  return driver_;
}
inline ::std::string* CqCreateStorage::release_driver() {
  clear_has_driver();
  if (driver_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = driver_;
    driver_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string identifier = 2;
inline bool CqCreateStorage::has_identifier() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CqCreateStorage::set_has_identifier() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CqCreateStorage::clear_has_identifier() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CqCreateStorage::clear_identifier() {
  if (identifier_ != &::google::protobuf::internal::kEmptyString) {
    identifier_->clear();
  }
  clear_has_identifier();
}
inline const ::std::string& CqCreateStorage::identifier() const {
  return *identifier_;
}
inline void CqCreateStorage::set_identifier(const ::std::string& value) {
  set_has_identifier();
  if (identifier_ == &::google::protobuf::internal::kEmptyString) {
    identifier_ = new ::std::string;
  }
  identifier_->assign(value);
}
inline void CqCreateStorage::set_identifier(const char* value) {
  set_has_identifier();
  if (identifier_ == &::google::protobuf::internal::kEmptyString) {
    identifier_ = new ::std::string;
  }
  identifier_->assign(value);
}
inline void CqCreateStorage::set_identifier(const char* value, size_t size) {
  set_has_identifier();
  if (identifier_ == &::google::protobuf::internal::kEmptyString) {
    identifier_ = new ::std::string;
  }
  identifier_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CqCreateStorage::mutable_identifier() {
  set_has_identifier();
  if (identifier_ == &::google::protobuf::internal::kEmptyString) {
    identifier_ = new ::std::string;
  }
  return identifier_;
}
inline ::std::string* CqCreateStorage::release_identifier() {
  clear_has_identifier();
  if (identifier_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = identifier_;
    identifier_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional .Db.Proto.StorageConfig config = 3;
inline bool CqCreateStorage::has_config() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CqCreateStorage::set_has_config() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CqCreateStorage::clear_has_config() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CqCreateStorage::clear_config() {
  if (config_ != NULL) config_->::Db::Proto::StorageConfig::Clear();
  clear_has_config();
}
inline const ::Db::Proto::StorageConfig& CqCreateStorage::config() const {
  return config_ != NULL ? *config_ : *default_instance_->config_;
}
inline ::Db::Proto::StorageConfig* CqCreateStorage::mutable_config() {
  set_has_config();
  if (config_ == NULL) config_ = new ::Db::Proto::StorageConfig;
  return config_;
}
inline ::Db::Proto::StorageConfig* CqCreateStorage::release_config() {
  clear_has_config();
  ::Db::Proto::StorageConfig* temp = config_;
  config_ = NULL;
  return temp;
}

// -------------------------------------------------------------------

// CqCreateView

// optional string driver = 1;
inline bool CqCreateView::has_driver() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CqCreateView::set_has_driver() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CqCreateView::clear_has_driver() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CqCreateView::clear_driver() {
  if (driver_ != &::google::protobuf::internal::kEmptyString) {
    driver_->clear();
  }
  clear_has_driver();
}
inline const ::std::string& CqCreateView::driver() const {
  return *driver_;
}
inline void CqCreateView::set_driver(const ::std::string& value) {
  set_has_driver();
  if (driver_ == &::google::protobuf::internal::kEmptyString) {
    driver_ = new ::std::string;
  }
  driver_->assign(value);
}
inline void CqCreateView::set_driver(const char* value) {
  set_has_driver();
  if (driver_ == &::google::protobuf::internal::kEmptyString) {
    driver_ = new ::std::string;
  }
  driver_->assign(value);
}
inline void CqCreateView::set_driver(const char* value, size_t size) {
  set_has_driver();
  if (driver_ == &::google::protobuf::internal::kEmptyString) {
    driver_ = new ::std::string;
  }
  driver_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CqCreateView::mutable_driver() {
  set_has_driver();
  if (driver_ == &::google::protobuf::internal::kEmptyString) {
    driver_ = new ::std::string;
  }
  return driver_;
}
inline ::std::string* CqCreateView::release_driver() {
  clear_has_driver();
  if (driver_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = driver_;
    driver_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string identifier = 2;
inline bool CqCreateView::has_identifier() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CqCreateView::set_has_identifier() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CqCreateView::clear_has_identifier() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CqCreateView::clear_identifier() {
  if (identifier_ != &::google::protobuf::internal::kEmptyString) {
    identifier_->clear();
  }
  clear_has_identifier();
}
inline const ::std::string& CqCreateView::identifier() const {
  return *identifier_;
}
inline void CqCreateView::set_identifier(const ::std::string& value) {
  set_has_identifier();
  if (identifier_ == &::google::protobuf::internal::kEmptyString) {
    identifier_ = new ::std::string;
  }
  identifier_->assign(value);
}
inline void CqCreateView::set_identifier(const char* value) {
  set_has_identifier();
  if (identifier_ == &::google::protobuf::internal::kEmptyString) {
    identifier_ = new ::std::string;
  }
  identifier_->assign(value);
}
inline void CqCreateView::set_identifier(const char* value, size_t size) {
  set_has_identifier();
  if (identifier_ == &::google::protobuf::internal::kEmptyString) {
    identifier_ = new ::std::string;
  }
  identifier_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CqCreateView::mutable_identifier() {
  set_has_identifier();
  if (identifier_ == &::google::protobuf::internal::kEmptyString) {
    identifier_ = new ::std::string;
  }
  return identifier_;
}
inline ::std::string* CqCreateView::release_identifier() {
  clear_has_identifier();
  if (identifier_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = identifier_;
    identifier_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional .Db.Proto.ViewConfig config = 3;
inline bool CqCreateView::has_config() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CqCreateView::set_has_config() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CqCreateView::clear_has_config() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CqCreateView::clear_config() {
  if (config_ != NULL) config_->::Db::Proto::ViewConfig::Clear();
  clear_has_config();
}
inline const ::Db::Proto::ViewConfig& CqCreateView::config() const {
  return config_ != NULL ? *config_ : *default_instance_->config_;
}
inline ::Db::Proto::ViewConfig* CqCreateView::mutable_config() {
  set_has_config();
  if (config_ == NULL) config_ = new ::Db::Proto::ViewConfig;
  return config_;
}
inline ::Db::Proto::ViewConfig* CqCreateView::release_config() {
  clear_has_config();
  ::Db::Proto::ViewConfig* temp = config_;
  config_ = NULL;
  return temp;
}

// -------------------------------------------------------------------

// CqUnlinkStorage

// required string identifier = 1;
inline bool CqUnlinkStorage::has_identifier() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CqUnlinkStorage::set_has_identifier() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CqUnlinkStorage::clear_has_identifier() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CqUnlinkStorage::clear_identifier() {
  if (identifier_ != &::google::protobuf::internal::kEmptyString) {
    identifier_->clear();
  }
  clear_has_identifier();
}
inline const ::std::string& CqUnlinkStorage::identifier() const {
  return *identifier_;
}
inline void CqUnlinkStorage::set_identifier(const ::std::string& value) {
  set_has_identifier();
  if (identifier_ == &::google::protobuf::internal::kEmptyString) {
    identifier_ = new ::std::string;
  }
  identifier_->assign(value);
}
inline void CqUnlinkStorage::set_identifier(const char* value) {
  set_has_identifier();
  if (identifier_ == &::google::protobuf::internal::kEmptyString) {
    identifier_ = new ::std::string;
  }
  identifier_->assign(value);
}
inline void CqUnlinkStorage::set_identifier(const char* value, size_t size) {
  set_has_identifier();
  if (identifier_ == &::google::protobuf::internal::kEmptyString) {
    identifier_ = new ::std::string;
  }
  identifier_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CqUnlinkStorage::mutable_identifier() {
  set_has_identifier();
  if (identifier_ == &::google::protobuf::internal::kEmptyString) {
    identifier_ = new ::std::string;
  }
  return identifier_;
}
inline ::std::string* CqUnlinkStorage::release_identifier() {
  clear_has_identifier();
  if (identifier_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = identifier_;
    identifier_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// CqUnlinkView

// required string identifier = 1;
inline bool CqUnlinkView::has_identifier() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CqUnlinkView::set_has_identifier() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CqUnlinkView::clear_has_identifier() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CqUnlinkView::clear_identifier() {
  if (identifier_ != &::google::protobuf::internal::kEmptyString) {
    identifier_->clear();
  }
  clear_has_identifier();
}
inline const ::std::string& CqUnlinkView::identifier() const {
  return *identifier_;
}
inline void CqUnlinkView::set_identifier(const ::std::string& value) {
  set_has_identifier();
  if (identifier_ == &::google::protobuf::internal::kEmptyString) {
    identifier_ = new ::std::string;
  }
  identifier_->assign(value);
}
inline void CqUnlinkView::set_identifier(const char* value) {
  set_has_identifier();
  if (identifier_ == &::google::protobuf::internal::kEmptyString) {
    identifier_ = new ::std::string;
  }
  identifier_->assign(value);
}
inline void CqUnlinkView::set_identifier(const char* value, size_t size) {
  set_has_identifier();
  if (identifier_ == &::google::protobuf::internal::kEmptyString) {
    identifier_ = new ::std::string;
  }
  identifier_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CqUnlinkView::mutable_identifier() {
  set_has_identifier();
  if (identifier_ == &::google::protobuf::internal::kEmptyString) {
    identifier_ = new ::std::string;
  }
  return identifier_;
}
inline ::std::string* CqUnlinkView::release_identifier() {
  clear_has_identifier();
  if (identifier_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = identifier_;
    identifier_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// CqUploadExtern

// required string file_name = 1;
inline bool CqUploadExtern::has_file_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CqUploadExtern::set_has_file_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CqUploadExtern::clear_has_file_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CqUploadExtern::clear_file_name() {
  if (file_name_ != &::google::protobuf::internal::kEmptyString) {
    file_name_->clear();
  }
  clear_has_file_name();
}
inline const ::std::string& CqUploadExtern::file_name() const {
  return *file_name_;
}
inline void CqUploadExtern::set_file_name(const ::std::string& value) {
  set_has_file_name();
  if (file_name_ == &::google::protobuf::internal::kEmptyString) {
    file_name_ = new ::std::string;
  }
  file_name_->assign(value);
}
inline void CqUploadExtern::set_file_name(const char* value) {
  set_has_file_name();
  if (file_name_ == &::google::protobuf::internal::kEmptyString) {
    file_name_ = new ::std::string;
  }
  file_name_->assign(value);
}
inline void CqUploadExtern::set_file_name(const char* value, size_t size) {
  set_has_file_name();
  if (file_name_ == &::google::protobuf::internal::kEmptyString) {
    file_name_ = new ::std::string;
  }
  file_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CqUploadExtern::mutable_file_name() {
  set_has_file_name();
  if (file_name_ == &::google::protobuf::internal::kEmptyString) {
    file_name_ = new ::std::string;
  }
  return file_name_;
}
inline ::std::string* CqUploadExtern::release_file_name() {
  clear_has_file_name();
  if (file_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = file_name_;
    file_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required bytes buffer = 2;
inline bool CqUploadExtern::has_buffer() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CqUploadExtern::set_has_buffer() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CqUploadExtern::clear_has_buffer() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CqUploadExtern::clear_buffer() {
  if (buffer_ != &::google::protobuf::internal::kEmptyString) {
    buffer_->clear();
  }
  clear_has_buffer();
}
inline const ::std::string& CqUploadExtern::buffer() const {
  return *buffer_;
}
inline void CqUploadExtern::set_buffer(const ::std::string& value) {
  set_has_buffer();
  if (buffer_ == &::google::protobuf::internal::kEmptyString) {
    buffer_ = new ::std::string;
  }
  buffer_->assign(value);
}
inline void CqUploadExtern::set_buffer(const char* value) {
  set_has_buffer();
  if (buffer_ == &::google::protobuf::internal::kEmptyString) {
    buffer_ = new ::std::string;
  }
  buffer_->assign(value);
}
inline void CqUploadExtern::set_buffer(const void* value, size_t size) {
  set_has_buffer();
  if (buffer_ == &::google::protobuf::internal::kEmptyString) {
    buffer_ = new ::std::string;
  }
  buffer_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CqUploadExtern::mutable_buffer() {
  set_has_buffer();
  if (buffer_ == &::google::protobuf::internal::kEmptyString) {
    buffer_ = new ::std::string;
  }
  return buffer_;
}
inline ::std::string* CqUploadExtern::release_buffer() {
  clear_has_buffer();
  if (buffer_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = buffer_;
    buffer_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// CqDownloadExtern

// required string file_name = 1;
inline bool CqDownloadExtern::has_file_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CqDownloadExtern::set_has_file_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CqDownloadExtern::clear_has_file_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CqDownloadExtern::clear_file_name() {
  if (file_name_ != &::google::protobuf::internal::kEmptyString) {
    file_name_->clear();
  }
  clear_has_file_name();
}
inline const ::std::string& CqDownloadExtern::file_name() const {
  return *file_name_;
}
inline void CqDownloadExtern::set_file_name(const ::std::string& value) {
  set_has_file_name();
  if (file_name_ == &::google::protobuf::internal::kEmptyString) {
    file_name_ = new ::std::string;
  }
  file_name_->assign(value);
}
inline void CqDownloadExtern::set_file_name(const char* value) {
  set_has_file_name();
  if (file_name_ == &::google::protobuf::internal::kEmptyString) {
    file_name_ = new ::std::string;
  }
  file_name_->assign(value);
}
inline void CqDownloadExtern::set_file_name(const char* value, size_t size) {
  set_has_file_name();
  if (file_name_ == &::google::protobuf::internal::kEmptyString) {
    file_name_ = new ::std::string;
  }
  file_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CqDownloadExtern::mutable_file_name() {
  set_has_file_name();
  if (file_name_ == &::google::protobuf::internal::kEmptyString) {
    file_name_ = new ::std::string;
  }
  return file_name_;
}
inline ::std::string* CqDownloadExtern::release_file_name() {
  clear_has_file_name();
  if (file_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = file_name_;
    file_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// CqShutdown

// -------------------------------------------------------------------

// SrFin_MutationInfo

// optional int64 document_id = 1;
inline bool SrFin_MutationInfo::has_document_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SrFin_MutationInfo::set_has_document_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SrFin_MutationInfo::clear_has_document_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SrFin_MutationInfo::clear_document_id() {
  document_id_ = GOOGLE_LONGLONG(0);
  clear_has_document_id();
}
inline ::google::protobuf::int64 SrFin_MutationInfo::document_id() const {
  return document_id_;
}
inline void SrFin_MutationInfo::set_document_id(::google::protobuf::int64 value) {
  set_has_document_id();
  document_id_ = value;
}

// -------------------------------------------------------------------

// SrFin

// optional .Api.Proto.ErrorCode error = 1;
inline bool SrFin::has_error() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SrFin::set_has_error() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SrFin::clear_has_error() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SrFin::clear_error() {
  error_ = 0;
  clear_has_error();
}
inline Api::Proto::ErrorCode SrFin::error() const {
  return static_cast< Api::Proto::ErrorCode >(error_);
}
inline void SrFin::set_error(Api::Proto::ErrorCode value) {
  GOOGLE_DCHECK(Api::Proto::ErrorCode_IsValid(value));
  set_has_error();
  error_ = value;
}

// optional int64 transaction_id = 2;
inline bool SrFin::has_transaction_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SrFin::set_has_transaction_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SrFin::clear_has_transaction_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SrFin::clear_transaction_id() {
  transaction_id_ = GOOGLE_LONGLONG(0);
  clear_has_transaction_id();
}
inline ::google::protobuf::int64 SrFin::transaction_id() const {
  return transaction_id_;
}
inline void SrFin::set_transaction_id(::google::protobuf::int64 value) {
  set_has_transaction_id();
  transaction_id_ = value;
}

// optional int64 sequence_id = 3;
inline bool SrFin::has_sequence_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SrFin::set_has_sequence_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SrFin::clear_has_sequence_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SrFin::clear_sequence_id() {
  sequence_id_ = GOOGLE_LONGLONG(0);
  clear_has_sequence_id();
}
inline ::google::protobuf::int64 SrFin::sequence_id() const {
  return sequence_id_;
}
inline void SrFin::set_sequence_id(::google::protobuf::int64 value) {
  set_has_sequence_id();
  sequence_id_ = value;
}

// repeated .Api.Proto.SrFin.MutationInfo mutations = 4;
inline int SrFin::mutations_size() const {
  return mutations_.size();
}
inline void SrFin::clear_mutations() {
  mutations_.Clear();
}
inline const ::Api::Proto::SrFin_MutationInfo& SrFin::mutations(int index) const {
  return mutations_.Get(index);
}
inline ::Api::Proto::SrFin_MutationInfo* SrFin::mutable_mutations(int index) {
  return mutations_.Mutable(index);
}
inline ::Api::Proto::SrFin_MutationInfo* SrFin::add_mutations() {
  return mutations_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Api::Proto::SrFin_MutationInfo >&
SrFin::mutations() const {
  return mutations_;
}
inline ::google::protobuf::RepeatedPtrField< ::Api::Proto::SrFin_MutationInfo >*
SrFin::mutable_mutations() {
  return &mutations_;
}

// -------------------------------------------------------------------

// SrRows

// repeated bytes row_data = 1;
inline int SrRows::row_data_size() const {
  return row_data_.size();
}
inline void SrRows::clear_row_data() {
  row_data_.Clear();
}
inline const ::std::string& SrRows::row_data(int index) const {
  return row_data_.Get(index);
}
inline ::std::string* SrRows::mutable_row_data(int index) {
  return row_data_.Mutable(index);
}
inline void SrRows::set_row_data(int index, const ::std::string& value) {
  row_data_.Mutable(index)->assign(value);
}
inline void SrRows::set_row_data(int index, const char* value) {
  row_data_.Mutable(index)->assign(value);
}
inline void SrRows::set_row_data(int index, const void* value, size_t size) {
  row_data_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SrRows::add_row_data() {
  return row_data_.Add();
}
inline void SrRows::add_row_data(const ::std::string& value) {
  row_data_.Add()->assign(value);
}
inline void SrRows::add_row_data(const char* value) {
  row_data_.Add()->assign(value);
}
inline void SrRows::add_row_data(const void* value, size_t size) {
  row_data_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
SrRows::row_data() const {
  return row_data_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
SrRows::mutable_row_data() {
  return &row_data_;
}

// -------------------------------------------------------------------

// SrBlob

// required bytes buffer = 1;
inline bool SrBlob::has_buffer() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SrBlob::set_has_buffer() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SrBlob::clear_has_buffer() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SrBlob::clear_buffer() {
  if (buffer_ != &::google::protobuf::internal::kEmptyString) {
    buffer_->clear();
  }
  clear_has_buffer();
}
inline const ::std::string& SrBlob::buffer() const {
  return *buffer_;
}
inline void SrBlob::set_buffer(const ::std::string& value) {
  set_has_buffer();
  if (buffer_ == &::google::protobuf::internal::kEmptyString) {
    buffer_ = new ::std::string;
  }
  buffer_->assign(value);
}
inline void SrBlob::set_buffer(const char* value) {
  set_has_buffer();
  if (buffer_ == &::google::protobuf::internal::kEmptyString) {
    buffer_ = new ::std::string;
  }
  buffer_->assign(value);
}
inline void SrBlob::set_buffer(const void* value, size_t size) {
  set_has_buffer();
  if (buffer_ == &::google::protobuf::internal::kEmptyString) {
    buffer_ = new ::std::string;
  }
  buffer_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SrBlob::mutable_buffer() {
  set_has_buffer();
  if (buffer_ == &::google::protobuf::internal::kEmptyString) {
    buffer_ = new ::std::string;
  }
  return buffer_;
}
inline ::std::string* SrBlob::release_buffer() {
  clear_has_buffer();
  if (buffer_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = buffer_;
    buffer_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace Proto
}  // namespace Api

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_proto_2fApi_2eproto__INCLUDED
