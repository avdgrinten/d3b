// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: proto/Api.proto

#ifndef PROTOBUF_proto_2fApi_2eproto__INCLUDED
#define PROTOBUF_proto_2fApi_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3000000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3000000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_util.h>
#include "proto/Config.pb.h"
// @@protoc_insertion_point(includes)

namespace Api {
namespace Proto {

// Internal implementation detail -- do not call these.
void protobuf_AddDesc_proto_2fApi_2eproto();
void protobuf_AssignDesc_proto_2fApi_2eproto();
void protobuf_ShutdownFile_proto_2fApi_2eproto();

class Constraint;
class CqApply;
class CqCreateStorage;
class CqCreateView;
class CqDownloadExtern;
class CqFetch;
class CqQuery;
class CqShortTransact;
class CqShutdown;
class CqTransaction;
class CqUnlinkStorage;
class CqUnlinkView;
class CqUpdate;
class CqUploadExtern;
class Mutation;
class SrBlob;
class SrFin;
class SrFin_MutationInfo;
class SrRows;

enum Mutation_Type {
  Mutation_Type_kTypeNone = 0,
  Mutation_Type_kTypeInsert = 1,
  Mutation_Type_kTypeModify = 2
};
bool Mutation_Type_IsValid(int value);
const Mutation_Type Mutation_Type_Type_MIN = Mutation_Type_kTypeNone;
const Mutation_Type Mutation_Type_Type_MAX = Mutation_Type_kTypeModify;
const int Mutation_Type_Type_ARRAYSIZE = Mutation_Type_Type_MAX + 1;

enum Constraint_Type {
  Constraint_Type_kTypeNone = 0,
  Constraint_Type_kTypeDocumentState = 1
};
bool Constraint_Type_IsValid(int value);
const Constraint_Type Constraint_Type_Type_MIN = Constraint_Type_kTypeNone;
const Constraint_Type Constraint_Type_Type_MAX = Constraint_Type_kTypeDocumentState;
const int Constraint_Type_Type_ARRAYSIZE = Constraint_Type_Type_MAX + 1;

enum CqApply_Type {
  CqApply_Type_kTypeNone = 0,
  CqApply_Type_kTypeSubmit = 1,
  CqApply_Type_kTypeSubmitCommit = 2,
  CqApply_Type_kTypeCommit = 3,
  CqApply_Type_kTypeRollback = 4
};
bool CqApply_Type_IsValid(int value);
const CqApply_Type CqApply_Type_Type_MIN = CqApply_Type_kTypeNone;
const CqApply_Type CqApply_Type_Type_MAX = CqApply_Type_kTypeRollback;
const int CqApply_Type_Type_ARRAYSIZE = CqApply_Type_Type_MAX + 1;

enum ErrorCode {
  kCodeNone = 0,
  kCodeSuccess = 1,
  kCodeIllegalRequest = 2,
  kCodeParseError = 3,
  kCodeIllegalState = 4,
  kCodeSubmitConstraintViolation = 32,
  kCodeSubmitConstraintConflict = 33,
  kCodeSubmitMutationConflict = 34,
  kCodeIllegalStorage = 128,
  kCodeIllegalView = 129
};
bool ErrorCode_IsValid(int value);
const ErrorCode ErrorCode_MIN = kCodeNone;
const ErrorCode ErrorCode_MAX = kCodeIllegalView;
const int ErrorCode_ARRAYSIZE = ErrorCode_MAX + 1;

enum ClientRequests {
  kCqFetch = 1,
  kCqQuery = 2,
  kCqShortTransact = 3,
  kCqTransaction = 4,
  kCqUpdate = 5,
  kCqApply = 6,
  kCqCreateStorage = 256,
  kCqCreateView = 257,
  kCqUnlinkStorage = 258,
  kCqUnlinkView = 259,
  kCqUploadExtern = 260,
  kCqDownloadExtern = 261,
  kCqShutdown = 262
};
bool ClientRequests_IsValid(int value);
const ClientRequests ClientRequests_MIN = kCqFetch;
const ClientRequests ClientRequests_MAX = kCqShutdown;
const int ClientRequests_ARRAYSIZE = ClientRequests_MAX + 1;

enum ServerResponses {
  kSrFin = 1,
  kSrRows = 2,
  kSrBlob = 3
};
bool ServerResponses_IsValid(int value);
const ServerResponses ServerResponses_MIN = kSrFin;
const ServerResponses ServerResponses_MAX = kSrBlob;
const int ServerResponses_ARRAYSIZE = ServerResponses_MAX + 1;

// ===================================================================

class Mutation : public ::google::protobuf::MessageLite {
 public:
  Mutation();
  virtual ~Mutation();

  Mutation(const Mutation& from);

  inline Mutation& operator=(const Mutation& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_.GetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  inline ::std::string* mutable_unknown_fields() {
    return _unknown_fields_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  static const Mutation& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const Mutation* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(Mutation* other);

  // implements Message ----------------------------------------------

  inline Mutation* New() const { return New(NULL); }

  Mutation* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const Mutation& from);
  void MergeFrom(const Mutation& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Mutation* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  typedef Mutation_Type Type;
  static const Type kTypeNone =
    Mutation_Type_kTypeNone;
  static const Type kTypeInsert =
    Mutation_Type_kTypeInsert;
  static const Type kTypeModify =
    Mutation_Type_kTypeModify;
  static inline bool Type_IsValid(int value) {
    return Mutation_Type_IsValid(value);
  }
  static const Type Type_MIN =
    Mutation_Type_Type_MIN;
  static const Type Type_MAX =
    Mutation_Type_Type_MAX;
  static const int Type_ARRAYSIZE =
    Mutation_Type_Type_ARRAYSIZE;

  // accessors -------------------------------------------------------

  // optional .Api.Proto.Mutation.Type type = 1;
  bool has_type() const;
  void clear_type();
  static const int kTypeFieldNumber = 1;
  ::Api::Proto::Mutation_Type type() const;
  void set_type(::Api::Proto::Mutation_Type value);

  // optional int64 document_id = 2;
  bool has_document_id() const;
  void clear_document_id();
  static const int kDocumentIdFieldNumber = 2;
  ::google::protobuf::int64 document_id() const;
  void set_document_id(::google::protobuf::int64 value);

  // optional string storage_name = 3;
  bool has_storage_name() const;
  void clear_storage_name();
  static const int kStorageNameFieldNumber = 3;
  const ::std::string& storage_name() const;
  void set_storage_name(const ::std::string& value);
  void set_storage_name(const char* value);
  void set_storage_name(const char* value, size_t size);
  ::std::string* mutable_storage_name();
  ::std::string* release_storage_name();
  void set_allocated_storage_name(::std::string* storage_name);

  // optional bytes buffer = 4;
  bool has_buffer() const;
  void clear_buffer();
  static const int kBufferFieldNumber = 4;
  const ::std::string& buffer() const;
  void set_buffer(const ::std::string& value);
  void set_buffer(const char* value);
  void set_buffer(const void* value, size_t size);
  ::std::string* mutable_buffer();
  ::std::string* release_buffer();
  void set_allocated_buffer(::std::string* buffer);

  // @@protoc_insertion_point(class_scope:Api.Proto.Mutation)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_document_id();
  inline void clear_has_document_id();
  inline void set_has_storage_name();
  inline void clear_has_storage_name();
  inline void set_has_buffer();
  inline void clear_has_buffer();

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int64 document_id_;
  ::google::protobuf::internal::ArenaStringPtr storage_name_;
  ::google::protobuf::internal::ArenaStringPtr buffer_;
  int type_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_proto_2fApi_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_proto_2fApi_2eproto();
  #endif
  friend void protobuf_AssignDesc_proto_2fApi_2eproto();
  friend void protobuf_ShutdownFile_proto_2fApi_2eproto();

  void InitAsDefaultInstance();
  static Mutation* default_instance_;
};
// -------------------------------------------------------------------

class Constraint : public ::google::protobuf::MessageLite {
 public:
  Constraint();
  virtual ~Constraint();

  Constraint(const Constraint& from);

  inline Constraint& operator=(const Constraint& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_.GetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  inline ::std::string* mutable_unknown_fields() {
    return _unknown_fields_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  static const Constraint& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const Constraint* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(Constraint* other);

  // implements Message ----------------------------------------------

  inline Constraint* New() const { return New(NULL); }

  Constraint* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const Constraint& from);
  void MergeFrom(const Constraint& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Constraint* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  typedef Constraint_Type Type;
  static const Type kTypeNone =
    Constraint_Type_kTypeNone;
  static const Type kTypeDocumentState =
    Constraint_Type_kTypeDocumentState;
  static inline bool Type_IsValid(int value) {
    return Constraint_Type_IsValid(value);
  }
  static const Type Type_MIN =
    Constraint_Type_Type_MIN;
  static const Type Type_MAX =
    Constraint_Type_Type_MAX;
  static const int Type_ARRAYSIZE =
    Constraint_Type_Type_ARRAYSIZE;

  // accessors -------------------------------------------------------

  // optional .Api.Proto.Constraint.Type type = 1;
  bool has_type() const;
  void clear_type();
  static const int kTypeFieldNumber = 1;
  ::Api::Proto::Constraint_Type type() const;
  void set_type(::Api::Proto::Constraint_Type value);

  // optional string storage_name = 2;
  bool has_storage_name() const;
  void clear_storage_name();
  static const int kStorageNameFieldNumber = 2;
  const ::std::string& storage_name() const;
  void set_storage_name(const ::std::string& value);
  void set_storage_name(const char* value);
  void set_storage_name(const char* value, size_t size);
  ::std::string* mutable_storage_name();
  ::std::string* release_storage_name();
  void set_allocated_storage_name(::std::string* storage_name);

  // optional int64 document_id = 3;
  bool has_document_id() const;
  void clear_document_id();
  static const int kDocumentIdFieldNumber = 3;
  ::google::protobuf::int64 document_id() const;
  void set_document_id(::google::protobuf::int64 value);

  // optional int64 sequence_id = 4;
  bool has_sequence_id() const;
  void clear_sequence_id();
  static const int kSequenceIdFieldNumber = 4;
  ::google::protobuf::int64 sequence_id() const;
  void set_sequence_id(::google::protobuf::int64 value);

  // optional bool must_exist = 5;
  bool has_must_exist() const;
  void clear_must_exist();
  static const int kMustExistFieldNumber = 5;
  bool must_exist() const;
  void set_must_exist(bool value);

  // optional bool match_sequence_id = 6;
  bool has_match_sequence_id() const;
  void clear_match_sequence_id();
  static const int kMatchSequenceIdFieldNumber = 6;
  bool match_sequence_id() const;
  void set_match_sequence_id(bool value);

  // @@protoc_insertion_point(class_scope:Api.Proto.Constraint)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_storage_name();
  inline void clear_has_storage_name();
  inline void set_has_document_id();
  inline void clear_has_document_id();
  inline void set_has_sequence_id();
  inline void clear_has_sequence_id();
  inline void set_has_must_exist();
  inline void clear_has_must_exist();
  inline void set_has_match_sequence_id();
  inline void clear_has_match_sequence_id();

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr storage_name_;
  ::google::protobuf::int64 document_id_;
  ::google::protobuf::int64 sequence_id_;
  int type_;
  bool must_exist_;
  bool match_sequence_id_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_proto_2fApi_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_proto_2fApi_2eproto();
  #endif
  friend void protobuf_AssignDesc_proto_2fApi_2eproto();
  friend void protobuf_ShutdownFile_proto_2fApi_2eproto();

  void InitAsDefaultInstance();
  static Constraint* default_instance_;
};
// -------------------------------------------------------------------

class CqFetch : public ::google::protobuf::MessageLite {
 public:
  CqFetch();
  virtual ~CqFetch();

  CqFetch(const CqFetch& from);

  inline CqFetch& operator=(const CqFetch& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_.GetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  inline ::std::string* mutable_unknown_fields() {
    return _unknown_fields_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  static const CqFetch& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CqFetch* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CqFetch* other);

  // implements Message ----------------------------------------------

  inline CqFetch* New() const { return New(NULL); }

  CqFetch* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CqFetch& from);
  void MergeFrom(const CqFetch& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(CqFetch* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string storage_name = 1;
  bool has_storage_name() const;
  void clear_storage_name();
  static const int kStorageNameFieldNumber = 1;
  const ::std::string& storage_name() const;
  void set_storage_name(const ::std::string& value);
  void set_storage_name(const char* value);
  void set_storage_name(const char* value, size_t size);
  ::std::string* mutable_storage_name();
  ::std::string* release_storage_name();
  void set_allocated_storage_name(::std::string* storage_name);

  // optional int64 sequence_id = 2;
  bool has_sequence_id() const;
  void clear_sequence_id();
  static const int kSequenceIdFieldNumber = 2;
  ::google::protobuf::int64 sequence_id() const;
  void set_sequence_id(::google::protobuf::int64 value);

  // optional int64 document_id = 3;
  bool has_document_id() const;
  void clear_document_id();
  static const int kDocumentIdFieldNumber = 3;
  ::google::protobuf::int64 document_id() const;
  void set_document_id(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:Api.Proto.CqFetch)
 private:
  inline void set_has_storage_name();
  inline void clear_has_storage_name();
  inline void set_has_sequence_id();
  inline void clear_has_sequence_id();
  inline void set_has_document_id();
  inline void clear_has_document_id();

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr storage_name_;
  ::google::protobuf::int64 sequence_id_;
  ::google::protobuf::int64 document_id_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_proto_2fApi_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_proto_2fApi_2eproto();
  #endif
  friend void protobuf_AssignDesc_proto_2fApi_2eproto();
  friend void protobuf_ShutdownFile_proto_2fApi_2eproto();

  void InitAsDefaultInstance();
  static CqFetch* default_instance_;
};
// -------------------------------------------------------------------

class CqQuery : public ::google::protobuf::MessageLite {
 public:
  CqQuery();
  virtual ~CqQuery();

  CqQuery(const CqQuery& from);

  inline CqQuery& operator=(const CqQuery& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_.GetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  inline ::std::string* mutable_unknown_fields() {
    return _unknown_fields_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  static const CqQuery& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CqQuery* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CqQuery* other);

  // implements Message ----------------------------------------------

  inline CqQuery* New() const { return New(NULL); }

  CqQuery* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CqQuery& from);
  void MergeFrom(const CqQuery& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(CqQuery* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string view_name = 1;
  bool has_view_name() const;
  void clear_view_name();
  static const int kViewNameFieldNumber = 1;
  const ::std::string& view_name() const;
  void set_view_name(const ::std::string& value);
  void set_view_name(const char* value);
  void set_view_name(const char* value, size_t size);
  ::std::string* mutable_view_name();
  ::std::string* release_view_name();
  void set_allocated_view_name(::std::string* view_name);

  // optional int64 sequence_id = 2;
  bool has_sequence_id() const;
  void clear_sequence_id();
  static const int kSequenceIdFieldNumber = 2;
  ::google::protobuf::int64 sequence_id() const;
  void set_sequence_id(::google::protobuf::int64 value);

  // repeated bytes keys = 3;
  int keys_size() const;
  void clear_keys();
  static const int kKeysFieldNumber = 3;
  const ::std::string& keys(int index) const;
  ::std::string* mutable_keys(int index);
  void set_keys(int index, const ::std::string& value);
  void set_keys(int index, const char* value);
  void set_keys(int index, const void* value, size_t size);
  ::std::string* add_keys();
  void add_keys(const ::std::string& value);
  void add_keys(const char* value);
  void add_keys(const void* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& keys() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_keys();

  // optional bytes from_key = 4;
  bool has_from_key() const;
  void clear_from_key();
  static const int kFromKeyFieldNumber = 4;
  const ::std::string& from_key() const;
  void set_from_key(const ::std::string& value);
  void set_from_key(const char* value);
  void set_from_key(const void* value, size_t size);
  ::std::string* mutable_from_key();
  ::std::string* release_from_key();
  void set_allocated_from_key(::std::string* from_key);

  // optional bytes to_key = 5;
  bool has_to_key() const;
  void clear_to_key();
  static const int kToKeyFieldNumber = 5;
  const ::std::string& to_key() const;
  void set_to_key(const ::std::string& value);
  void set_to_key(const char* value);
  void set_to_key(const void* value, size_t size);
  ::std::string* mutable_to_key();
  ::std::string* release_to_key();
  void set_allocated_to_key(::std::string* to_key);

  // optional uint32 limit = 6;
  bool has_limit() const;
  void clear_limit();
  static const int kLimitFieldNumber = 6;
  ::google::protobuf::uint32 limit() const;
  void set_limit(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:Api.Proto.CqQuery)
 private:
  inline void set_has_view_name();
  inline void clear_has_view_name();
  inline void set_has_sequence_id();
  inline void clear_has_sequence_id();
  inline void set_has_from_key();
  inline void clear_has_from_key();
  inline void set_has_to_key();
  inline void clear_has_to_key();
  inline void set_has_limit();
  inline void clear_has_limit();

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr view_name_;
  ::google::protobuf::int64 sequence_id_;
  ::google::protobuf::RepeatedPtrField< ::std::string> keys_;
  ::google::protobuf::internal::ArenaStringPtr from_key_;
  ::google::protobuf::internal::ArenaStringPtr to_key_;
  ::google::protobuf::uint32 limit_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_proto_2fApi_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_proto_2fApi_2eproto();
  #endif
  friend void protobuf_AssignDesc_proto_2fApi_2eproto();
  friend void protobuf_ShutdownFile_proto_2fApi_2eproto();

  void InitAsDefaultInstance();
  static CqQuery* default_instance_;
};
// -------------------------------------------------------------------

class CqShortTransact : public ::google::protobuf::MessageLite {
 public:
  CqShortTransact();
  virtual ~CqShortTransact();

  CqShortTransact(const CqShortTransact& from);

  inline CqShortTransact& operator=(const CqShortTransact& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_.GetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  inline ::std::string* mutable_unknown_fields() {
    return _unknown_fields_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  static const CqShortTransact& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CqShortTransact* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CqShortTransact* other);

  // implements Message ----------------------------------------------

  inline CqShortTransact* New() const { return New(NULL); }

  CqShortTransact* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CqShortTransact& from);
  void MergeFrom(const CqShortTransact& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(CqShortTransact* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .Api.Proto.Mutation mutations = 1;
  int mutations_size() const;
  void clear_mutations();
  static const int kMutationsFieldNumber = 1;
  const ::Api::Proto::Mutation& mutations(int index) const;
  ::Api::Proto::Mutation* mutable_mutations(int index);
  ::Api::Proto::Mutation* add_mutations();
  ::google::protobuf::RepeatedPtrField< ::Api::Proto::Mutation >*
      mutable_mutations();
  const ::google::protobuf::RepeatedPtrField< ::Api::Proto::Mutation >&
      mutations() const;

  // repeated .Api.Proto.Constraint constraints = 2;
  int constraints_size() const;
  void clear_constraints();
  static const int kConstraintsFieldNumber = 2;
  const ::Api::Proto::Constraint& constraints(int index) const;
  ::Api::Proto::Constraint* mutable_constraints(int index);
  ::Api::Proto::Constraint* add_constraints();
  ::google::protobuf::RepeatedPtrField< ::Api::Proto::Constraint >*
      mutable_constraints();
  const ::google::protobuf::RepeatedPtrField< ::Api::Proto::Constraint >&
      constraints() const;

  // @@protoc_insertion_point(class_scope:Api.Proto.CqShortTransact)
 private:

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::Api::Proto::Mutation > mutations_;
  ::google::protobuf::RepeatedPtrField< ::Api::Proto::Constraint > constraints_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_proto_2fApi_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_proto_2fApi_2eproto();
  #endif
  friend void protobuf_AssignDesc_proto_2fApi_2eproto();
  friend void protobuf_ShutdownFile_proto_2fApi_2eproto();

  void InitAsDefaultInstance();
  static CqShortTransact* default_instance_;
};
// -------------------------------------------------------------------

class CqTransaction : public ::google::protobuf::MessageLite {
 public:
  CqTransaction();
  virtual ~CqTransaction();

  CqTransaction(const CqTransaction& from);

  inline CqTransaction& operator=(const CqTransaction& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_.GetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  inline ::std::string* mutable_unknown_fields() {
    return _unknown_fields_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  static const CqTransaction& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CqTransaction* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CqTransaction* other);

  // implements Message ----------------------------------------------

  inline CqTransaction* New() const { return New(NULL); }

  CqTransaction* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CqTransaction& from);
  void MergeFrom(const CqTransaction& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(CqTransaction* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:Api.Proto.CqTransaction)
 private:

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_proto_2fApi_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_proto_2fApi_2eproto();
  #endif
  friend void protobuf_AssignDesc_proto_2fApi_2eproto();
  friend void protobuf_ShutdownFile_proto_2fApi_2eproto();

  void InitAsDefaultInstance();
  static CqTransaction* default_instance_;
};
// -------------------------------------------------------------------

class CqUpdate : public ::google::protobuf::MessageLite {
 public:
  CqUpdate();
  virtual ~CqUpdate();

  CqUpdate(const CqUpdate& from);

  inline CqUpdate& operator=(const CqUpdate& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_.GetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  inline ::std::string* mutable_unknown_fields() {
    return _unknown_fields_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  static const CqUpdate& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CqUpdate* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CqUpdate* other);

  // implements Message ----------------------------------------------

  inline CqUpdate* New() const { return New(NULL); }

  CqUpdate* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CqUpdate& from);
  void MergeFrom(const CqUpdate& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(CqUpdate* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int64 transaction_id = 1;
  bool has_transaction_id() const;
  void clear_transaction_id();
  static const int kTransactionIdFieldNumber = 1;
  ::google::protobuf::int64 transaction_id() const;
  void set_transaction_id(::google::protobuf::int64 value);

  // repeated .Api.Proto.Mutation mutations = 2;
  int mutations_size() const;
  void clear_mutations();
  static const int kMutationsFieldNumber = 2;
  const ::Api::Proto::Mutation& mutations(int index) const;
  ::Api::Proto::Mutation* mutable_mutations(int index);
  ::Api::Proto::Mutation* add_mutations();
  ::google::protobuf::RepeatedPtrField< ::Api::Proto::Mutation >*
      mutable_mutations();
  const ::google::protobuf::RepeatedPtrField< ::Api::Proto::Mutation >&
      mutations() const;

  // repeated .Api.Proto.Constraint constraints = 3;
  int constraints_size() const;
  void clear_constraints();
  static const int kConstraintsFieldNumber = 3;
  const ::Api::Proto::Constraint& constraints(int index) const;
  ::Api::Proto::Constraint* mutable_constraints(int index);
  ::Api::Proto::Constraint* add_constraints();
  ::google::protobuf::RepeatedPtrField< ::Api::Proto::Constraint >*
      mutable_constraints();
  const ::google::protobuf::RepeatedPtrField< ::Api::Proto::Constraint >&
      constraints() const;

  // @@protoc_insertion_point(class_scope:Api.Proto.CqUpdate)
 private:
  inline void set_has_transaction_id();
  inline void clear_has_transaction_id();

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int64 transaction_id_;
  ::google::protobuf::RepeatedPtrField< ::Api::Proto::Mutation > mutations_;
  ::google::protobuf::RepeatedPtrField< ::Api::Proto::Constraint > constraints_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_proto_2fApi_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_proto_2fApi_2eproto();
  #endif
  friend void protobuf_AssignDesc_proto_2fApi_2eproto();
  friend void protobuf_ShutdownFile_proto_2fApi_2eproto();

  void InitAsDefaultInstance();
  static CqUpdate* default_instance_;
};
// -------------------------------------------------------------------

class CqApply : public ::google::protobuf::MessageLite {
 public:
  CqApply();
  virtual ~CqApply();

  CqApply(const CqApply& from);

  inline CqApply& operator=(const CqApply& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_.GetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  inline ::std::string* mutable_unknown_fields() {
    return _unknown_fields_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  static const CqApply& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CqApply* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CqApply* other);

  // implements Message ----------------------------------------------

  inline CqApply* New() const { return New(NULL); }

  CqApply* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CqApply& from);
  void MergeFrom(const CqApply& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(CqApply* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  typedef CqApply_Type Type;
  static const Type kTypeNone =
    CqApply_Type_kTypeNone;
  static const Type kTypeSubmit =
    CqApply_Type_kTypeSubmit;
  static const Type kTypeSubmitCommit =
    CqApply_Type_kTypeSubmitCommit;
  static const Type kTypeCommit =
    CqApply_Type_kTypeCommit;
  static const Type kTypeRollback =
    CqApply_Type_kTypeRollback;
  static inline bool Type_IsValid(int value) {
    return CqApply_Type_IsValid(value);
  }
  static const Type Type_MIN =
    CqApply_Type_Type_MIN;
  static const Type Type_MAX =
    CqApply_Type_Type_MAX;
  static const int Type_ARRAYSIZE =
    CqApply_Type_Type_ARRAYSIZE;

  // accessors -------------------------------------------------------

  // optional int64 transaction_id = 1;
  bool has_transaction_id() const;
  void clear_transaction_id();
  static const int kTransactionIdFieldNumber = 1;
  ::google::protobuf::int64 transaction_id() const;
  void set_transaction_id(::google::protobuf::int64 value);

  // optional .Api.Proto.CqApply.Type type = 2;
  bool has_type() const;
  void clear_type();
  static const int kTypeFieldNumber = 2;
  ::Api::Proto::CqApply_Type type() const;
  void set_type(::Api::Proto::CqApply_Type value);

  // @@protoc_insertion_point(class_scope:Api.Proto.CqApply)
 private:
  inline void set_has_transaction_id();
  inline void clear_has_transaction_id();
  inline void set_has_type();
  inline void clear_has_type();

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int64 transaction_id_;
  int type_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_proto_2fApi_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_proto_2fApi_2eproto();
  #endif
  friend void protobuf_AssignDesc_proto_2fApi_2eproto();
  friend void protobuf_ShutdownFile_proto_2fApi_2eproto();

  void InitAsDefaultInstance();
  static CqApply* default_instance_;
};
// -------------------------------------------------------------------

class CqCreateStorage : public ::google::protobuf::MessageLite {
 public:
  CqCreateStorage();
  virtual ~CqCreateStorage();

  CqCreateStorage(const CqCreateStorage& from);

  inline CqCreateStorage& operator=(const CqCreateStorage& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_.GetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  inline ::std::string* mutable_unknown_fields() {
    return _unknown_fields_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  static const CqCreateStorage& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CqCreateStorage* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CqCreateStorage* other);

  // implements Message ----------------------------------------------

  inline CqCreateStorage* New() const { return New(NULL); }

  CqCreateStorage* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CqCreateStorage& from);
  void MergeFrom(const CqCreateStorage& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(CqCreateStorage* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string driver = 1;
  bool has_driver() const;
  void clear_driver();
  static const int kDriverFieldNumber = 1;
  const ::std::string& driver() const;
  void set_driver(const ::std::string& value);
  void set_driver(const char* value);
  void set_driver(const char* value, size_t size);
  ::std::string* mutable_driver();
  ::std::string* release_driver();
  void set_allocated_driver(::std::string* driver);

  // optional string identifier = 2;
  bool has_identifier() const;
  void clear_identifier();
  static const int kIdentifierFieldNumber = 2;
  const ::std::string& identifier() const;
  void set_identifier(const ::std::string& value);
  void set_identifier(const char* value);
  void set_identifier(const char* value, size_t size);
  ::std::string* mutable_identifier();
  ::std::string* release_identifier();
  void set_allocated_identifier(::std::string* identifier);

  // optional .Db.Proto.StorageConfig config = 3;
  bool has_config() const;
  void clear_config();
  static const int kConfigFieldNumber = 3;
  const ::Db::Proto::StorageConfig& config() const;
  ::Db::Proto::StorageConfig* mutable_config();
  ::Db::Proto::StorageConfig* release_config();
  void set_allocated_config(::Db::Proto::StorageConfig* config);

  // @@protoc_insertion_point(class_scope:Api.Proto.CqCreateStorage)
 private:
  inline void set_has_driver();
  inline void clear_has_driver();
  inline void set_has_identifier();
  inline void clear_has_identifier();
  inline void set_has_config();
  inline void clear_has_config();

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr driver_;
  ::google::protobuf::internal::ArenaStringPtr identifier_;
  ::Db::Proto::StorageConfig* config_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_proto_2fApi_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_proto_2fApi_2eproto();
  #endif
  friend void protobuf_AssignDesc_proto_2fApi_2eproto();
  friend void protobuf_ShutdownFile_proto_2fApi_2eproto();

  void InitAsDefaultInstance();
  static CqCreateStorage* default_instance_;
};
// -------------------------------------------------------------------

class CqCreateView : public ::google::protobuf::MessageLite {
 public:
  CqCreateView();
  virtual ~CqCreateView();

  CqCreateView(const CqCreateView& from);

  inline CqCreateView& operator=(const CqCreateView& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_.GetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  inline ::std::string* mutable_unknown_fields() {
    return _unknown_fields_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  static const CqCreateView& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CqCreateView* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CqCreateView* other);

  // implements Message ----------------------------------------------

  inline CqCreateView* New() const { return New(NULL); }

  CqCreateView* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CqCreateView& from);
  void MergeFrom(const CqCreateView& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(CqCreateView* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string driver = 1;
  bool has_driver() const;
  void clear_driver();
  static const int kDriverFieldNumber = 1;
  const ::std::string& driver() const;
  void set_driver(const ::std::string& value);
  void set_driver(const char* value);
  void set_driver(const char* value, size_t size);
  ::std::string* mutable_driver();
  ::std::string* release_driver();
  void set_allocated_driver(::std::string* driver);

  // optional string identifier = 2;
  bool has_identifier() const;
  void clear_identifier();
  static const int kIdentifierFieldNumber = 2;
  const ::std::string& identifier() const;
  void set_identifier(const ::std::string& value);
  void set_identifier(const char* value);
  void set_identifier(const char* value, size_t size);
  ::std::string* mutable_identifier();
  ::std::string* release_identifier();
  void set_allocated_identifier(::std::string* identifier);

  // optional .Db.Proto.ViewConfig config = 3;
  bool has_config() const;
  void clear_config();
  static const int kConfigFieldNumber = 3;
  const ::Db::Proto::ViewConfig& config() const;
  ::Db::Proto::ViewConfig* mutable_config();
  ::Db::Proto::ViewConfig* release_config();
  void set_allocated_config(::Db::Proto::ViewConfig* config);

  // @@protoc_insertion_point(class_scope:Api.Proto.CqCreateView)
 private:
  inline void set_has_driver();
  inline void clear_has_driver();
  inline void set_has_identifier();
  inline void clear_has_identifier();
  inline void set_has_config();
  inline void clear_has_config();

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr driver_;
  ::google::protobuf::internal::ArenaStringPtr identifier_;
  ::Db::Proto::ViewConfig* config_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_proto_2fApi_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_proto_2fApi_2eproto();
  #endif
  friend void protobuf_AssignDesc_proto_2fApi_2eproto();
  friend void protobuf_ShutdownFile_proto_2fApi_2eproto();

  void InitAsDefaultInstance();
  static CqCreateView* default_instance_;
};
// -------------------------------------------------------------------

class CqUnlinkStorage : public ::google::protobuf::MessageLite {
 public:
  CqUnlinkStorage();
  virtual ~CqUnlinkStorage();

  CqUnlinkStorage(const CqUnlinkStorage& from);

  inline CqUnlinkStorage& operator=(const CqUnlinkStorage& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_.GetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  inline ::std::string* mutable_unknown_fields() {
    return _unknown_fields_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  static const CqUnlinkStorage& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CqUnlinkStorage* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CqUnlinkStorage* other);

  // implements Message ----------------------------------------------

  inline CqUnlinkStorage* New() const { return New(NULL); }

  CqUnlinkStorage* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CqUnlinkStorage& from);
  void MergeFrom(const CqUnlinkStorage& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(CqUnlinkStorage* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string identifier = 1;
  bool has_identifier() const;
  void clear_identifier();
  static const int kIdentifierFieldNumber = 1;
  const ::std::string& identifier() const;
  void set_identifier(const ::std::string& value);
  void set_identifier(const char* value);
  void set_identifier(const char* value, size_t size);
  ::std::string* mutable_identifier();
  ::std::string* release_identifier();
  void set_allocated_identifier(::std::string* identifier);

  // @@protoc_insertion_point(class_scope:Api.Proto.CqUnlinkStorage)
 private:
  inline void set_has_identifier();
  inline void clear_has_identifier();

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr identifier_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_proto_2fApi_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_proto_2fApi_2eproto();
  #endif
  friend void protobuf_AssignDesc_proto_2fApi_2eproto();
  friend void protobuf_ShutdownFile_proto_2fApi_2eproto();

  void InitAsDefaultInstance();
  static CqUnlinkStorage* default_instance_;
};
// -------------------------------------------------------------------

class CqUnlinkView : public ::google::protobuf::MessageLite {
 public:
  CqUnlinkView();
  virtual ~CqUnlinkView();

  CqUnlinkView(const CqUnlinkView& from);

  inline CqUnlinkView& operator=(const CqUnlinkView& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_.GetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  inline ::std::string* mutable_unknown_fields() {
    return _unknown_fields_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  static const CqUnlinkView& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CqUnlinkView* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CqUnlinkView* other);

  // implements Message ----------------------------------------------

  inline CqUnlinkView* New() const { return New(NULL); }

  CqUnlinkView* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CqUnlinkView& from);
  void MergeFrom(const CqUnlinkView& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(CqUnlinkView* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string identifier = 1;
  bool has_identifier() const;
  void clear_identifier();
  static const int kIdentifierFieldNumber = 1;
  const ::std::string& identifier() const;
  void set_identifier(const ::std::string& value);
  void set_identifier(const char* value);
  void set_identifier(const char* value, size_t size);
  ::std::string* mutable_identifier();
  ::std::string* release_identifier();
  void set_allocated_identifier(::std::string* identifier);

  // @@protoc_insertion_point(class_scope:Api.Proto.CqUnlinkView)
 private:
  inline void set_has_identifier();
  inline void clear_has_identifier();

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr identifier_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_proto_2fApi_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_proto_2fApi_2eproto();
  #endif
  friend void protobuf_AssignDesc_proto_2fApi_2eproto();
  friend void protobuf_ShutdownFile_proto_2fApi_2eproto();

  void InitAsDefaultInstance();
  static CqUnlinkView* default_instance_;
};
// -------------------------------------------------------------------

class CqUploadExtern : public ::google::protobuf::MessageLite {
 public:
  CqUploadExtern();
  virtual ~CqUploadExtern();

  CqUploadExtern(const CqUploadExtern& from);

  inline CqUploadExtern& operator=(const CqUploadExtern& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_.GetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  inline ::std::string* mutable_unknown_fields() {
    return _unknown_fields_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  static const CqUploadExtern& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CqUploadExtern* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CqUploadExtern* other);

  // implements Message ----------------------------------------------

  inline CqUploadExtern* New() const { return New(NULL); }

  CqUploadExtern* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CqUploadExtern& from);
  void MergeFrom(const CqUploadExtern& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(CqUploadExtern* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string file_name = 1;
  bool has_file_name() const;
  void clear_file_name();
  static const int kFileNameFieldNumber = 1;
  const ::std::string& file_name() const;
  void set_file_name(const ::std::string& value);
  void set_file_name(const char* value);
  void set_file_name(const char* value, size_t size);
  ::std::string* mutable_file_name();
  ::std::string* release_file_name();
  void set_allocated_file_name(::std::string* file_name);

  // required bytes buffer = 2;
  bool has_buffer() const;
  void clear_buffer();
  static const int kBufferFieldNumber = 2;
  const ::std::string& buffer() const;
  void set_buffer(const ::std::string& value);
  void set_buffer(const char* value);
  void set_buffer(const void* value, size_t size);
  ::std::string* mutable_buffer();
  ::std::string* release_buffer();
  void set_allocated_buffer(::std::string* buffer);

  // @@protoc_insertion_point(class_scope:Api.Proto.CqUploadExtern)
 private:
  inline void set_has_file_name();
  inline void clear_has_file_name();
  inline void set_has_buffer();
  inline void clear_has_buffer();

  // helper for ByteSize()
  int RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr file_name_;
  ::google::protobuf::internal::ArenaStringPtr buffer_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_proto_2fApi_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_proto_2fApi_2eproto();
  #endif
  friend void protobuf_AssignDesc_proto_2fApi_2eproto();
  friend void protobuf_ShutdownFile_proto_2fApi_2eproto();

  void InitAsDefaultInstance();
  static CqUploadExtern* default_instance_;
};
// -------------------------------------------------------------------

class CqDownloadExtern : public ::google::protobuf::MessageLite {
 public:
  CqDownloadExtern();
  virtual ~CqDownloadExtern();

  CqDownloadExtern(const CqDownloadExtern& from);

  inline CqDownloadExtern& operator=(const CqDownloadExtern& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_.GetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  inline ::std::string* mutable_unknown_fields() {
    return _unknown_fields_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  static const CqDownloadExtern& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CqDownloadExtern* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CqDownloadExtern* other);

  // implements Message ----------------------------------------------

  inline CqDownloadExtern* New() const { return New(NULL); }

  CqDownloadExtern* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CqDownloadExtern& from);
  void MergeFrom(const CqDownloadExtern& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(CqDownloadExtern* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string file_name = 1;
  bool has_file_name() const;
  void clear_file_name();
  static const int kFileNameFieldNumber = 1;
  const ::std::string& file_name() const;
  void set_file_name(const ::std::string& value);
  void set_file_name(const char* value);
  void set_file_name(const char* value, size_t size);
  ::std::string* mutable_file_name();
  ::std::string* release_file_name();
  void set_allocated_file_name(::std::string* file_name);

  // @@protoc_insertion_point(class_scope:Api.Proto.CqDownloadExtern)
 private:
  inline void set_has_file_name();
  inline void clear_has_file_name();

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr file_name_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_proto_2fApi_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_proto_2fApi_2eproto();
  #endif
  friend void protobuf_AssignDesc_proto_2fApi_2eproto();
  friend void protobuf_ShutdownFile_proto_2fApi_2eproto();

  void InitAsDefaultInstance();
  static CqDownloadExtern* default_instance_;
};
// -------------------------------------------------------------------

class CqShutdown : public ::google::protobuf::MessageLite {
 public:
  CqShutdown();
  virtual ~CqShutdown();

  CqShutdown(const CqShutdown& from);

  inline CqShutdown& operator=(const CqShutdown& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_.GetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  inline ::std::string* mutable_unknown_fields() {
    return _unknown_fields_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  static const CqShutdown& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CqShutdown* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CqShutdown* other);

  // implements Message ----------------------------------------------

  inline CqShutdown* New() const { return New(NULL); }

  CqShutdown* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CqShutdown& from);
  void MergeFrom(const CqShutdown& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(CqShutdown* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:Api.Proto.CqShutdown)
 private:

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_proto_2fApi_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_proto_2fApi_2eproto();
  #endif
  friend void protobuf_AssignDesc_proto_2fApi_2eproto();
  friend void protobuf_ShutdownFile_proto_2fApi_2eproto();

  void InitAsDefaultInstance();
  static CqShutdown* default_instance_;
};
// -------------------------------------------------------------------

class SrFin_MutationInfo : public ::google::protobuf::MessageLite {
 public:
  SrFin_MutationInfo();
  virtual ~SrFin_MutationInfo();

  SrFin_MutationInfo(const SrFin_MutationInfo& from);

  inline SrFin_MutationInfo& operator=(const SrFin_MutationInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_.GetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  inline ::std::string* mutable_unknown_fields() {
    return _unknown_fields_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  static const SrFin_MutationInfo& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const SrFin_MutationInfo* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(SrFin_MutationInfo* other);

  // implements Message ----------------------------------------------

  inline SrFin_MutationInfo* New() const { return New(NULL); }

  SrFin_MutationInfo* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const SrFin_MutationInfo& from);
  void MergeFrom(const SrFin_MutationInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(SrFin_MutationInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int64 document_id = 1;
  bool has_document_id() const;
  void clear_document_id();
  static const int kDocumentIdFieldNumber = 1;
  ::google::protobuf::int64 document_id() const;
  void set_document_id(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:Api.Proto.SrFin.MutationInfo)
 private:
  inline void set_has_document_id();
  inline void clear_has_document_id();

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int64 document_id_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_proto_2fApi_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_proto_2fApi_2eproto();
  #endif
  friend void protobuf_AssignDesc_proto_2fApi_2eproto();
  friend void protobuf_ShutdownFile_proto_2fApi_2eproto();

  void InitAsDefaultInstance();
  static SrFin_MutationInfo* default_instance_;
};
// -------------------------------------------------------------------

class SrFin : public ::google::protobuf::MessageLite {
 public:
  SrFin();
  virtual ~SrFin();

  SrFin(const SrFin& from);

  inline SrFin& operator=(const SrFin& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_.GetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  inline ::std::string* mutable_unknown_fields() {
    return _unknown_fields_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  static const SrFin& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const SrFin* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(SrFin* other);

  // implements Message ----------------------------------------------

  inline SrFin* New() const { return New(NULL); }

  SrFin* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const SrFin& from);
  void MergeFrom(const SrFin& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(SrFin* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  typedef SrFin_MutationInfo MutationInfo;

  // accessors -------------------------------------------------------

  // optional .Api.Proto.ErrorCode error = 1;
  bool has_error() const;
  void clear_error();
  static const int kErrorFieldNumber = 1;
  ::Api::Proto::ErrorCode error() const;
  void set_error(::Api::Proto::ErrorCode value);

  // optional int64 transaction_id = 2;
  bool has_transaction_id() const;
  void clear_transaction_id();
  static const int kTransactionIdFieldNumber = 2;
  ::google::protobuf::int64 transaction_id() const;
  void set_transaction_id(::google::protobuf::int64 value);

  // optional int64 sequence_id = 3;
  bool has_sequence_id() const;
  void clear_sequence_id();
  static const int kSequenceIdFieldNumber = 3;
  ::google::protobuf::int64 sequence_id() const;
  void set_sequence_id(::google::protobuf::int64 value);

  // repeated .Api.Proto.SrFin.MutationInfo mutations = 4;
  int mutations_size() const;
  void clear_mutations();
  static const int kMutationsFieldNumber = 4;
  const ::Api::Proto::SrFin_MutationInfo& mutations(int index) const;
  ::Api::Proto::SrFin_MutationInfo* mutable_mutations(int index);
  ::Api::Proto::SrFin_MutationInfo* add_mutations();
  ::google::protobuf::RepeatedPtrField< ::Api::Proto::SrFin_MutationInfo >*
      mutable_mutations();
  const ::google::protobuf::RepeatedPtrField< ::Api::Proto::SrFin_MutationInfo >&
      mutations() const;

  // @@protoc_insertion_point(class_scope:Api.Proto.SrFin)
 private:
  inline void set_has_error();
  inline void clear_has_error();
  inline void set_has_transaction_id();
  inline void clear_has_transaction_id();
  inline void set_has_sequence_id();
  inline void clear_has_sequence_id();

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int64 transaction_id_;
  ::google::protobuf::int64 sequence_id_;
  ::google::protobuf::RepeatedPtrField< ::Api::Proto::SrFin_MutationInfo > mutations_;
  int error_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_proto_2fApi_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_proto_2fApi_2eproto();
  #endif
  friend void protobuf_AssignDesc_proto_2fApi_2eproto();
  friend void protobuf_ShutdownFile_proto_2fApi_2eproto();

  void InitAsDefaultInstance();
  static SrFin* default_instance_;
};
// -------------------------------------------------------------------

class SrRows : public ::google::protobuf::MessageLite {
 public:
  SrRows();
  virtual ~SrRows();

  SrRows(const SrRows& from);

  inline SrRows& operator=(const SrRows& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_.GetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  inline ::std::string* mutable_unknown_fields() {
    return _unknown_fields_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  static const SrRows& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const SrRows* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(SrRows* other);

  // implements Message ----------------------------------------------

  inline SrRows* New() const { return New(NULL); }

  SrRows* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const SrRows& from);
  void MergeFrom(const SrRows& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(SrRows* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated bytes row_data = 1;
  int row_data_size() const;
  void clear_row_data();
  static const int kRowDataFieldNumber = 1;
  const ::std::string& row_data(int index) const;
  ::std::string* mutable_row_data(int index);
  void set_row_data(int index, const ::std::string& value);
  void set_row_data(int index, const char* value);
  void set_row_data(int index, const void* value, size_t size);
  ::std::string* add_row_data();
  void add_row_data(const ::std::string& value);
  void add_row_data(const char* value);
  void add_row_data(const void* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& row_data() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_row_data();

  // @@protoc_insertion_point(class_scope:Api.Proto.SrRows)
 private:

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::std::string> row_data_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_proto_2fApi_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_proto_2fApi_2eproto();
  #endif
  friend void protobuf_AssignDesc_proto_2fApi_2eproto();
  friend void protobuf_ShutdownFile_proto_2fApi_2eproto();

  void InitAsDefaultInstance();
  static SrRows* default_instance_;
};
// -------------------------------------------------------------------

class SrBlob : public ::google::protobuf::MessageLite {
 public:
  SrBlob();
  virtual ~SrBlob();

  SrBlob(const SrBlob& from);

  inline SrBlob& operator=(const SrBlob& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_.GetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  inline ::std::string* mutable_unknown_fields() {
    return _unknown_fields_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  static const SrBlob& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const SrBlob* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(SrBlob* other);

  // implements Message ----------------------------------------------

  inline SrBlob* New() const { return New(NULL); }

  SrBlob* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const SrBlob& from);
  void MergeFrom(const SrBlob& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(SrBlob* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bytes buffer = 1;
  bool has_buffer() const;
  void clear_buffer();
  static const int kBufferFieldNumber = 1;
  const ::std::string& buffer() const;
  void set_buffer(const ::std::string& value);
  void set_buffer(const char* value);
  void set_buffer(const void* value, size_t size);
  ::std::string* mutable_buffer();
  ::std::string* release_buffer();
  void set_allocated_buffer(::std::string* buffer);

  // @@protoc_insertion_point(class_scope:Api.Proto.SrBlob)
 private:
  inline void set_has_buffer();
  inline void clear_has_buffer();

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr buffer_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_proto_2fApi_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_proto_2fApi_2eproto();
  #endif
  friend void protobuf_AssignDesc_proto_2fApi_2eproto();
  friend void protobuf_ShutdownFile_proto_2fApi_2eproto();

  void InitAsDefaultInstance();
  static SrBlob* default_instance_;
};
// ===================================================================


// ===================================================================

#if !PROTOBUF_INLINE_NOT_IN_HEADERS
// Mutation

// optional .Api.Proto.Mutation.Type type = 1;
inline bool Mutation::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Mutation::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Mutation::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Mutation::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::Api::Proto::Mutation_Type Mutation::type() const {
  // @@protoc_insertion_point(field_get:Api.Proto.Mutation.type)
  return static_cast< ::Api::Proto::Mutation_Type >(type_);
}
inline void Mutation::set_type(::Api::Proto::Mutation_Type value) {
  assert(::Api::Proto::Mutation_Type_IsValid(value));
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:Api.Proto.Mutation.type)
}

// optional int64 document_id = 2;
inline bool Mutation::has_document_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Mutation::set_has_document_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Mutation::clear_has_document_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Mutation::clear_document_id() {
  document_id_ = GOOGLE_LONGLONG(0);
  clear_has_document_id();
}
inline ::google::protobuf::int64 Mutation::document_id() const {
  // @@protoc_insertion_point(field_get:Api.Proto.Mutation.document_id)
  return document_id_;
}
inline void Mutation::set_document_id(::google::protobuf::int64 value) {
  set_has_document_id();
  document_id_ = value;
  // @@protoc_insertion_point(field_set:Api.Proto.Mutation.document_id)
}

// optional string storage_name = 3;
inline bool Mutation::has_storage_name() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Mutation::set_has_storage_name() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Mutation::clear_has_storage_name() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Mutation::clear_storage_name() {
  storage_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_storage_name();
}
inline const ::std::string& Mutation::storage_name() const {
  // @@protoc_insertion_point(field_get:Api.Proto.Mutation.storage_name)
  return storage_name_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Mutation::set_storage_name(const ::std::string& value) {
  set_has_storage_name();
  storage_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Api.Proto.Mutation.storage_name)
}
inline void Mutation::set_storage_name(const char* value) {
  set_has_storage_name();
  storage_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Api.Proto.Mutation.storage_name)
}
inline void Mutation::set_storage_name(const char* value, size_t size) {
  set_has_storage_name();
  storage_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Api.Proto.Mutation.storage_name)
}
inline ::std::string* Mutation::mutable_storage_name() {
  set_has_storage_name();
  // @@protoc_insertion_point(field_mutable:Api.Proto.Mutation.storage_name)
  return storage_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Mutation::release_storage_name() {
  // @@protoc_insertion_point(field_release:Api.Proto.Mutation.storage_name)
  clear_has_storage_name();
  return storage_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Mutation::set_allocated_storage_name(::std::string* storage_name) {
  if (storage_name != NULL) {
    set_has_storage_name();
  } else {
    clear_has_storage_name();
  }
  storage_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), storage_name);
  // @@protoc_insertion_point(field_set_allocated:Api.Proto.Mutation.storage_name)
}

// optional bytes buffer = 4;
inline bool Mutation::has_buffer() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Mutation::set_has_buffer() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Mutation::clear_has_buffer() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Mutation::clear_buffer() {
  buffer_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_buffer();
}
inline const ::std::string& Mutation::buffer() const {
  // @@protoc_insertion_point(field_get:Api.Proto.Mutation.buffer)
  return buffer_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Mutation::set_buffer(const ::std::string& value) {
  set_has_buffer();
  buffer_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Api.Proto.Mutation.buffer)
}
inline void Mutation::set_buffer(const char* value) {
  set_has_buffer();
  buffer_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Api.Proto.Mutation.buffer)
}
inline void Mutation::set_buffer(const void* value, size_t size) {
  set_has_buffer();
  buffer_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Api.Proto.Mutation.buffer)
}
inline ::std::string* Mutation::mutable_buffer() {
  set_has_buffer();
  // @@protoc_insertion_point(field_mutable:Api.Proto.Mutation.buffer)
  return buffer_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Mutation::release_buffer() {
  // @@protoc_insertion_point(field_release:Api.Proto.Mutation.buffer)
  clear_has_buffer();
  return buffer_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Mutation::set_allocated_buffer(::std::string* buffer) {
  if (buffer != NULL) {
    set_has_buffer();
  } else {
    clear_has_buffer();
  }
  buffer_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), buffer);
  // @@protoc_insertion_point(field_set_allocated:Api.Proto.Mutation.buffer)
}

// -------------------------------------------------------------------

// Constraint

// optional .Api.Proto.Constraint.Type type = 1;
inline bool Constraint::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Constraint::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Constraint::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Constraint::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::Api::Proto::Constraint_Type Constraint::type() const {
  // @@protoc_insertion_point(field_get:Api.Proto.Constraint.type)
  return static_cast< ::Api::Proto::Constraint_Type >(type_);
}
inline void Constraint::set_type(::Api::Proto::Constraint_Type value) {
  assert(::Api::Proto::Constraint_Type_IsValid(value));
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:Api.Proto.Constraint.type)
}

// optional string storage_name = 2;
inline bool Constraint::has_storage_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Constraint::set_has_storage_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Constraint::clear_has_storage_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Constraint::clear_storage_name() {
  storage_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_storage_name();
}
inline const ::std::string& Constraint::storage_name() const {
  // @@protoc_insertion_point(field_get:Api.Proto.Constraint.storage_name)
  return storage_name_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Constraint::set_storage_name(const ::std::string& value) {
  set_has_storage_name();
  storage_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Api.Proto.Constraint.storage_name)
}
inline void Constraint::set_storage_name(const char* value) {
  set_has_storage_name();
  storage_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Api.Proto.Constraint.storage_name)
}
inline void Constraint::set_storage_name(const char* value, size_t size) {
  set_has_storage_name();
  storage_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Api.Proto.Constraint.storage_name)
}
inline ::std::string* Constraint::mutable_storage_name() {
  set_has_storage_name();
  // @@protoc_insertion_point(field_mutable:Api.Proto.Constraint.storage_name)
  return storage_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Constraint::release_storage_name() {
  // @@protoc_insertion_point(field_release:Api.Proto.Constraint.storage_name)
  clear_has_storage_name();
  return storage_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Constraint::set_allocated_storage_name(::std::string* storage_name) {
  if (storage_name != NULL) {
    set_has_storage_name();
  } else {
    clear_has_storage_name();
  }
  storage_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), storage_name);
  // @@protoc_insertion_point(field_set_allocated:Api.Proto.Constraint.storage_name)
}

// optional int64 document_id = 3;
inline bool Constraint::has_document_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Constraint::set_has_document_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Constraint::clear_has_document_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Constraint::clear_document_id() {
  document_id_ = GOOGLE_LONGLONG(0);
  clear_has_document_id();
}
inline ::google::protobuf::int64 Constraint::document_id() const {
  // @@protoc_insertion_point(field_get:Api.Proto.Constraint.document_id)
  return document_id_;
}
inline void Constraint::set_document_id(::google::protobuf::int64 value) {
  set_has_document_id();
  document_id_ = value;
  // @@protoc_insertion_point(field_set:Api.Proto.Constraint.document_id)
}

// optional int64 sequence_id = 4;
inline bool Constraint::has_sequence_id() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Constraint::set_has_sequence_id() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Constraint::clear_has_sequence_id() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Constraint::clear_sequence_id() {
  sequence_id_ = GOOGLE_LONGLONG(0);
  clear_has_sequence_id();
}
inline ::google::protobuf::int64 Constraint::sequence_id() const {
  // @@protoc_insertion_point(field_get:Api.Proto.Constraint.sequence_id)
  return sequence_id_;
}
inline void Constraint::set_sequence_id(::google::protobuf::int64 value) {
  set_has_sequence_id();
  sequence_id_ = value;
  // @@protoc_insertion_point(field_set:Api.Proto.Constraint.sequence_id)
}

// optional bool must_exist = 5;
inline bool Constraint::has_must_exist() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Constraint::set_has_must_exist() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Constraint::clear_has_must_exist() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Constraint::clear_must_exist() {
  must_exist_ = false;
  clear_has_must_exist();
}
inline bool Constraint::must_exist() const {
  // @@protoc_insertion_point(field_get:Api.Proto.Constraint.must_exist)
  return must_exist_;
}
inline void Constraint::set_must_exist(bool value) {
  set_has_must_exist();
  must_exist_ = value;
  // @@protoc_insertion_point(field_set:Api.Proto.Constraint.must_exist)
}

// optional bool match_sequence_id = 6;
inline bool Constraint::has_match_sequence_id() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Constraint::set_has_match_sequence_id() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Constraint::clear_has_match_sequence_id() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Constraint::clear_match_sequence_id() {
  match_sequence_id_ = false;
  clear_has_match_sequence_id();
}
inline bool Constraint::match_sequence_id() const {
  // @@protoc_insertion_point(field_get:Api.Proto.Constraint.match_sequence_id)
  return match_sequence_id_;
}
inline void Constraint::set_match_sequence_id(bool value) {
  set_has_match_sequence_id();
  match_sequence_id_ = value;
  // @@protoc_insertion_point(field_set:Api.Proto.Constraint.match_sequence_id)
}

// -------------------------------------------------------------------

// CqFetch

// optional string storage_name = 1;
inline bool CqFetch::has_storage_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CqFetch::set_has_storage_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CqFetch::clear_has_storage_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CqFetch::clear_storage_name() {
  storage_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_storage_name();
}
inline const ::std::string& CqFetch::storage_name() const {
  // @@protoc_insertion_point(field_get:Api.Proto.CqFetch.storage_name)
  return storage_name_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CqFetch::set_storage_name(const ::std::string& value) {
  set_has_storage_name();
  storage_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Api.Proto.CqFetch.storage_name)
}
inline void CqFetch::set_storage_name(const char* value) {
  set_has_storage_name();
  storage_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Api.Proto.CqFetch.storage_name)
}
inline void CqFetch::set_storage_name(const char* value, size_t size) {
  set_has_storage_name();
  storage_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Api.Proto.CqFetch.storage_name)
}
inline ::std::string* CqFetch::mutable_storage_name() {
  set_has_storage_name();
  // @@protoc_insertion_point(field_mutable:Api.Proto.CqFetch.storage_name)
  return storage_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* CqFetch::release_storage_name() {
  // @@protoc_insertion_point(field_release:Api.Proto.CqFetch.storage_name)
  clear_has_storage_name();
  return storage_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CqFetch::set_allocated_storage_name(::std::string* storage_name) {
  if (storage_name != NULL) {
    set_has_storage_name();
  } else {
    clear_has_storage_name();
  }
  storage_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), storage_name);
  // @@protoc_insertion_point(field_set_allocated:Api.Proto.CqFetch.storage_name)
}

// optional int64 sequence_id = 2;
inline bool CqFetch::has_sequence_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CqFetch::set_has_sequence_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CqFetch::clear_has_sequence_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CqFetch::clear_sequence_id() {
  sequence_id_ = GOOGLE_LONGLONG(0);
  clear_has_sequence_id();
}
inline ::google::protobuf::int64 CqFetch::sequence_id() const {
  // @@protoc_insertion_point(field_get:Api.Proto.CqFetch.sequence_id)
  return sequence_id_;
}
inline void CqFetch::set_sequence_id(::google::protobuf::int64 value) {
  set_has_sequence_id();
  sequence_id_ = value;
  // @@protoc_insertion_point(field_set:Api.Proto.CqFetch.sequence_id)
}

// optional int64 document_id = 3;
inline bool CqFetch::has_document_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CqFetch::set_has_document_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CqFetch::clear_has_document_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CqFetch::clear_document_id() {
  document_id_ = GOOGLE_LONGLONG(0);
  clear_has_document_id();
}
inline ::google::protobuf::int64 CqFetch::document_id() const {
  // @@protoc_insertion_point(field_get:Api.Proto.CqFetch.document_id)
  return document_id_;
}
inline void CqFetch::set_document_id(::google::protobuf::int64 value) {
  set_has_document_id();
  document_id_ = value;
  // @@protoc_insertion_point(field_set:Api.Proto.CqFetch.document_id)
}

// -------------------------------------------------------------------

// CqQuery

// optional string view_name = 1;
inline bool CqQuery::has_view_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CqQuery::set_has_view_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CqQuery::clear_has_view_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CqQuery::clear_view_name() {
  view_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_view_name();
}
inline const ::std::string& CqQuery::view_name() const {
  // @@protoc_insertion_point(field_get:Api.Proto.CqQuery.view_name)
  return view_name_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CqQuery::set_view_name(const ::std::string& value) {
  set_has_view_name();
  view_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Api.Proto.CqQuery.view_name)
}
inline void CqQuery::set_view_name(const char* value) {
  set_has_view_name();
  view_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Api.Proto.CqQuery.view_name)
}
inline void CqQuery::set_view_name(const char* value, size_t size) {
  set_has_view_name();
  view_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Api.Proto.CqQuery.view_name)
}
inline ::std::string* CqQuery::mutable_view_name() {
  set_has_view_name();
  // @@protoc_insertion_point(field_mutable:Api.Proto.CqQuery.view_name)
  return view_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* CqQuery::release_view_name() {
  // @@protoc_insertion_point(field_release:Api.Proto.CqQuery.view_name)
  clear_has_view_name();
  return view_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CqQuery::set_allocated_view_name(::std::string* view_name) {
  if (view_name != NULL) {
    set_has_view_name();
  } else {
    clear_has_view_name();
  }
  view_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), view_name);
  // @@protoc_insertion_point(field_set_allocated:Api.Proto.CqQuery.view_name)
}

// optional int64 sequence_id = 2;
inline bool CqQuery::has_sequence_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CqQuery::set_has_sequence_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CqQuery::clear_has_sequence_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CqQuery::clear_sequence_id() {
  sequence_id_ = GOOGLE_LONGLONG(0);
  clear_has_sequence_id();
}
inline ::google::protobuf::int64 CqQuery::sequence_id() const {
  // @@protoc_insertion_point(field_get:Api.Proto.CqQuery.sequence_id)
  return sequence_id_;
}
inline void CqQuery::set_sequence_id(::google::protobuf::int64 value) {
  set_has_sequence_id();
  sequence_id_ = value;
  // @@protoc_insertion_point(field_set:Api.Proto.CqQuery.sequence_id)
}

// repeated bytes keys = 3;
inline int CqQuery::keys_size() const {
  return keys_.size();
}
inline void CqQuery::clear_keys() {
  keys_.Clear();
}
inline const ::std::string& CqQuery::keys(int index) const {
  // @@protoc_insertion_point(field_get:Api.Proto.CqQuery.keys)
  return keys_.Get(index);
}
inline ::std::string* CqQuery::mutable_keys(int index) {
  // @@protoc_insertion_point(field_mutable:Api.Proto.CqQuery.keys)
  return keys_.Mutable(index);
}
inline void CqQuery::set_keys(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:Api.Proto.CqQuery.keys)
  keys_.Mutable(index)->assign(value);
}
inline void CqQuery::set_keys(int index, const char* value) {
  keys_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:Api.Proto.CqQuery.keys)
}
inline void CqQuery::set_keys(int index, const void* value, size_t size) {
  keys_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Api.Proto.CqQuery.keys)
}
inline ::std::string* CqQuery::add_keys() {
  // @@protoc_insertion_point(field_add_mutable:Api.Proto.CqQuery.keys)
  return keys_.Add();
}
inline void CqQuery::add_keys(const ::std::string& value) {
  keys_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:Api.Proto.CqQuery.keys)
}
inline void CqQuery::add_keys(const char* value) {
  keys_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:Api.Proto.CqQuery.keys)
}
inline void CqQuery::add_keys(const void* value, size_t size) {
  keys_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:Api.Proto.CqQuery.keys)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
CqQuery::keys() const {
  // @@protoc_insertion_point(field_list:Api.Proto.CqQuery.keys)
  return keys_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
CqQuery::mutable_keys() {
  // @@protoc_insertion_point(field_mutable_list:Api.Proto.CqQuery.keys)
  return &keys_;
}

// optional bytes from_key = 4;
inline bool CqQuery::has_from_key() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CqQuery::set_has_from_key() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CqQuery::clear_has_from_key() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CqQuery::clear_from_key() {
  from_key_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_from_key();
}
inline const ::std::string& CqQuery::from_key() const {
  // @@protoc_insertion_point(field_get:Api.Proto.CqQuery.from_key)
  return from_key_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CqQuery::set_from_key(const ::std::string& value) {
  set_has_from_key();
  from_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Api.Proto.CqQuery.from_key)
}
inline void CqQuery::set_from_key(const char* value) {
  set_has_from_key();
  from_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Api.Proto.CqQuery.from_key)
}
inline void CqQuery::set_from_key(const void* value, size_t size) {
  set_has_from_key();
  from_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Api.Proto.CqQuery.from_key)
}
inline ::std::string* CqQuery::mutable_from_key() {
  set_has_from_key();
  // @@protoc_insertion_point(field_mutable:Api.Proto.CqQuery.from_key)
  return from_key_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* CqQuery::release_from_key() {
  // @@protoc_insertion_point(field_release:Api.Proto.CqQuery.from_key)
  clear_has_from_key();
  return from_key_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CqQuery::set_allocated_from_key(::std::string* from_key) {
  if (from_key != NULL) {
    set_has_from_key();
  } else {
    clear_has_from_key();
  }
  from_key_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from_key);
  // @@protoc_insertion_point(field_set_allocated:Api.Proto.CqQuery.from_key)
}

// optional bytes to_key = 5;
inline bool CqQuery::has_to_key() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CqQuery::set_has_to_key() {
  _has_bits_[0] |= 0x00000010u;
}
inline void CqQuery::clear_has_to_key() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void CqQuery::clear_to_key() {
  to_key_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_to_key();
}
inline const ::std::string& CqQuery::to_key() const {
  // @@protoc_insertion_point(field_get:Api.Proto.CqQuery.to_key)
  return to_key_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CqQuery::set_to_key(const ::std::string& value) {
  set_has_to_key();
  to_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Api.Proto.CqQuery.to_key)
}
inline void CqQuery::set_to_key(const char* value) {
  set_has_to_key();
  to_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Api.Proto.CqQuery.to_key)
}
inline void CqQuery::set_to_key(const void* value, size_t size) {
  set_has_to_key();
  to_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Api.Proto.CqQuery.to_key)
}
inline ::std::string* CqQuery::mutable_to_key() {
  set_has_to_key();
  // @@protoc_insertion_point(field_mutable:Api.Proto.CqQuery.to_key)
  return to_key_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* CqQuery::release_to_key() {
  // @@protoc_insertion_point(field_release:Api.Proto.CqQuery.to_key)
  clear_has_to_key();
  return to_key_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CqQuery::set_allocated_to_key(::std::string* to_key) {
  if (to_key != NULL) {
    set_has_to_key();
  } else {
    clear_has_to_key();
  }
  to_key_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), to_key);
  // @@protoc_insertion_point(field_set_allocated:Api.Proto.CqQuery.to_key)
}

// optional uint32 limit = 6;
inline bool CqQuery::has_limit() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void CqQuery::set_has_limit() {
  _has_bits_[0] |= 0x00000020u;
}
inline void CqQuery::clear_has_limit() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void CqQuery::clear_limit() {
  limit_ = 0u;
  clear_has_limit();
}
inline ::google::protobuf::uint32 CqQuery::limit() const {
  // @@protoc_insertion_point(field_get:Api.Proto.CqQuery.limit)
  return limit_;
}
inline void CqQuery::set_limit(::google::protobuf::uint32 value) {
  set_has_limit();
  limit_ = value;
  // @@protoc_insertion_point(field_set:Api.Proto.CqQuery.limit)
}

// -------------------------------------------------------------------

// CqShortTransact

// repeated .Api.Proto.Mutation mutations = 1;
inline int CqShortTransact::mutations_size() const {
  return mutations_.size();
}
inline void CqShortTransact::clear_mutations() {
  mutations_.Clear();
}
inline const ::Api::Proto::Mutation& CqShortTransact::mutations(int index) const {
  // @@protoc_insertion_point(field_get:Api.Proto.CqShortTransact.mutations)
  return mutations_.Get(index);
}
inline ::Api::Proto::Mutation* CqShortTransact::mutable_mutations(int index) {
  // @@protoc_insertion_point(field_mutable:Api.Proto.CqShortTransact.mutations)
  return mutations_.Mutable(index);
}
inline ::Api::Proto::Mutation* CqShortTransact::add_mutations() {
  // @@protoc_insertion_point(field_add:Api.Proto.CqShortTransact.mutations)
  return mutations_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::Api::Proto::Mutation >*
CqShortTransact::mutable_mutations() {
  // @@protoc_insertion_point(field_mutable_list:Api.Proto.CqShortTransact.mutations)
  return &mutations_;
}
inline const ::google::protobuf::RepeatedPtrField< ::Api::Proto::Mutation >&
CqShortTransact::mutations() const {
  // @@protoc_insertion_point(field_list:Api.Proto.CqShortTransact.mutations)
  return mutations_;
}

// repeated .Api.Proto.Constraint constraints = 2;
inline int CqShortTransact::constraints_size() const {
  return constraints_.size();
}
inline void CqShortTransact::clear_constraints() {
  constraints_.Clear();
}
inline const ::Api::Proto::Constraint& CqShortTransact::constraints(int index) const {
  // @@protoc_insertion_point(field_get:Api.Proto.CqShortTransact.constraints)
  return constraints_.Get(index);
}
inline ::Api::Proto::Constraint* CqShortTransact::mutable_constraints(int index) {
  // @@protoc_insertion_point(field_mutable:Api.Proto.CqShortTransact.constraints)
  return constraints_.Mutable(index);
}
inline ::Api::Proto::Constraint* CqShortTransact::add_constraints() {
  // @@protoc_insertion_point(field_add:Api.Proto.CqShortTransact.constraints)
  return constraints_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::Api::Proto::Constraint >*
CqShortTransact::mutable_constraints() {
  // @@protoc_insertion_point(field_mutable_list:Api.Proto.CqShortTransact.constraints)
  return &constraints_;
}
inline const ::google::protobuf::RepeatedPtrField< ::Api::Proto::Constraint >&
CqShortTransact::constraints() const {
  // @@protoc_insertion_point(field_list:Api.Proto.CqShortTransact.constraints)
  return constraints_;
}

// -------------------------------------------------------------------

// CqTransaction

// -------------------------------------------------------------------

// CqUpdate

// optional int64 transaction_id = 1;
inline bool CqUpdate::has_transaction_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CqUpdate::set_has_transaction_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CqUpdate::clear_has_transaction_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CqUpdate::clear_transaction_id() {
  transaction_id_ = GOOGLE_LONGLONG(0);
  clear_has_transaction_id();
}
inline ::google::protobuf::int64 CqUpdate::transaction_id() const {
  // @@protoc_insertion_point(field_get:Api.Proto.CqUpdate.transaction_id)
  return transaction_id_;
}
inline void CqUpdate::set_transaction_id(::google::protobuf::int64 value) {
  set_has_transaction_id();
  transaction_id_ = value;
  // @@protoc_insertion_point(field_set:Api.Proto.CqUpdate.transaction_id)
}

// repeated .Api.Proto.Mutation mutations = 2;
inline int CqUpdate::mutations_size() const {
  return mutations_.size();
}
inline void CqUpdate::clear_mutations() {
  mutations_.Clear();
}
inline const ::Api::Proto::Mutation& CqUpdate::mutations(int index) const {
  // @@protoc_insertion_point(field_get:Api.Proto.CqUpdate.mutations)
  return mutations_.Get(index);
}
inline ::Api::Proto::Mutation* CqUpdate::mutable_mutations(int index) {
  // @@protoc_insertion_point(field_mutable:Api.Proto.CqUpdate.mutations)
  return mutations_.Mutable(index);
}
inline ::Api::Proto::Mutation* CqUpdate::add_mutations() {
  // @@protoc_insertion_point(field_add:Api.Proto.CqUpdate.mutations)
  return mutations_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::Api::Proto::Mutation >*
CqUpdate::mutable_mutations() {
  // @@protoc_insertion_point(field_mutable_list:Api.Proto.CqUpdate.mutations)
  return &mutations_;
}
inline const ::google::protobuf::RepeatedPtrField< ::Api::Proto::Mutation >&
CqUpdate::mutations() const {
  // @@protoc_insertion_point(field_list:Api.Proto.CqUpdate.mutations)
  return mutations_;
}

// repeated .Api.Proto.Constraint constraints = 3;
inline int CqUpdate::constraints_size() const {
  return constraints_.size();
}
inline void CqUpdate::clear_constraints() {
  constraints_.Clear();
}
inline const ::Api::Proto::Constraint& CqUpdate::constraints(int index) const {
  // @@protoc_insertion_point(field_get:Api.Proto.CqUpdate.constraints)
  return constraints_.Get(index);
}
inline ::Api::Proto::Constraint* CqUpdate::mutable_constraints(int index) {
  // @@protoc_insertion_point(field_mutable:Api.Proto.CqUpdate.constraints)
  return constraints_.Mutable(index);
}
inline ::Api::Proto::Constraint* CqUpdate::add_constraints() {
  // @@protoc_insertion_point(field_add:Api.Proto.CqUpdate.constraints)
  return constraints_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::Api::Proto::Constraint >*
CqUpdate::mutable_constraints() {
  // @@protoc_insertion_point(field_mutable_list:Api.Proto.CqUpdate.constraints)
  return &constraints_;
}
inline const ::google::protobuf::RepeatedPtrField< ::Api::Proto::Constraint >&
CqUpdate::constraints() const {
  // @@protoc_insertion_point(field_list:Api.Proto.CqUpdate.constraints)
  return constraints_;
}

// -------------------------------------------------------------------

// CqApply

// optional int64 transaction_id = 1;
inline bool CqApply::has_transaction_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CqApply::set_has_transaction_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CqApply::clear_has_transaction_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CqApply::clear_transaction_id() {
  transaction_id_ = GOOGLE_LONGLONG(0);
  clear_has_transaction_id();
}
inline ::google::protobuf::int64 CqApply::transaction_id() const {
  // @@protoc_insertion_point(field_get:Api.Proto.CqApply.transaction_id)
  return transaction_id_;
}
inline void CqApply::set_transaction_id(::google::protobuf::int64 value) {
  set_has_transaction_id();
  transaction_id_ = value;
  // @@protoc_insertion_point(field_set:Api.Proto.CqApply.transaction_id)
}

// optional .Api.Proto.CqApply.Type type = 2;
inline bool CqApply::has_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CqApply::set_has_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CqApply::clear_has_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CqApply::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::Api::Proto::CqApply_Type CqApply::type() const {
  // @@protoc_insertion_point(field_get:Api.Proto.CqApply.type)
  return static_cast< ::Api::Proto::CqApply_Type >(type_);
}
inline void CqApply::set_type(::Api::Proto::CqApply_Type value) {
  assert(::Api::Proto::CqApply_Type_IsValid(value));
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:Api.Proto.CqApply.type)
}

// -------------------------------------------------------------------

// CqCreateStorage

// optional string driver = 1;
inline bool CqCreateStorage::has_driver() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CqCreateStorage::set_has_driver() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CqCreateStorage::clear_has_driver() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CqCreateStorage::clear_driver() {
  driver_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_driver();
}
inline const ::std::string& CqCreateStorage::driver() const {
  // @@protoc_insertion_point(field_get:Api.Proto.CqCreateStorage.driver)
  return driver_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CqCreateStorage::set_driver(const ::std::string& value) {
  set_has_driver();
  driver_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Api.Proto.CqCreateStorage.driver)
}
inline void CqCreateStorage::set_driver(const char* value) {
  set_has_driver();
  driver_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Api.Proto.CqCreateStorage.driver)
}
inline void CqCreateStorage::set_driver(const char* value, size_t size) {
  set_has_driver();
  driver_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Api.Proto.CqCreateStorage.driver)
}
inline ::std::string* CqCreateStorage::mutable_driver() {
  set_has_driver();
  // @@protoc_insertion_point(field_mutable:Api.Proto.CqCreateStorage.driver)
  return driver_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* CqCreateStorage::release_driver() {
  // @@protoc_insertion_point(field_release:Api.Proto.CqCreateStorage.driver)
  clear_has_driver();
  return driver_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CqCreateStorage::set_allocated_driver(::std::string* driver) {
  if (driver != NULL) {
    set_has_driver();
  } else {
    clear_has_driver();
  }
  driver_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), driver);
  // @@protoc_insertion_point(field_set_allocated:Api.Proto.CqCreateStorage.driver)
}

// optional string identifier = 2;
inline bool CqCreateStorage::has_identifier() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CqCreateStorage::set_has_identifier() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CqCreateStorage::clear_has_identifier() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CqCreateStorage::clear_identifier() {
  identifier_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_identifier();
}
inline const ::std::string& CqCreateStorage::identifier() const {
  // @@protoc_insertion_point(field_get:Api.Proto.CqCreateStorage.identifier)
  return identifier_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CqCreateStorage::set_identifier(const ::std::string& value) {
  set_has_identifier();
  identifier_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Api.Proto.CqCreateStorage.identifier)
}
inline void CqCreateStorage::set_identifier(const char* value) {
  set_has_identifier();
  identifier_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Api.Proto.CqCreateStorage.identifier)
}
inline void CqCreateStorage::set_identifier(const char* value, size_t size) {
  set_has_identifier();
  identifier_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Api.Proto.CqCreateStorage.identifier)
}
inline ::std::string* CqCreateStorage::mutable_identifier() {
  set_has_identifier();
  // @@protoc_insertion_point(field_mutable:Api.Proto.CqCreateStorage.identifier)
  return identifier_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* CqCreateStorage::release_identifier() {
  // @@protoc_insertion_point(field_release:Api.Proto.CqCreateStorage.identifier)
  clear_has_identifier();
  return identifier_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CqCreateStorage::set_allocated_identifier(::std::string* identifier) {
  if (identifier != NULL) {
    set_has_identifier();
  } else {
    clear_has_identifier();
  }
  identifier_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), identifier);
  // @@protoc_insertion_point(field_set_allocated:Api.Proto.CqCreateStorage.identifier)
}

// optional .Db.Proto.StorageConfig config = 3;
inline bool CqCreateStorage::has_config() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CqCreateStorage::set_has_config() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CqCreateStorage::clear_has_config() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CqCreateStorage::clear_config() {
  if (config_ != NULL) config_->::Db::Proto::StorageConfig::Clear();
  clear_has_config();
}
inline const ::Db::Proto::StorageConfig& CqCreateStorage::config() const {
  // @@protoc_insertion_point(field_get:Api.Proto.CqCreateStorage.config)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return config_ != NULL ? *config_ : *default_instance().config_;
#else
  return config_ != NULL ? *config_ : *default_instance_->config_;
#endif
}
inline ::Db::Proto::StorageConfig* CqCreateStorage::mutable_config() {
  set_has_config();
  if (config_ == NULL) {
    config_ = new ::Db::Proto::StorageConfig;
  }
  // @@protoc_insertion_point(field_mutable:Api.Proto.CqCreateStorage.config)
  return config_;
}
inline ::Db::Proto::StorageConfig* CqCreateStorage::release_config() {
  // @@protoc_insertion_point(field_release:Api.Proto.CqCreateStorage.config)
  clear_has_config();
  ::Db::Proto::StorageConfig* temp = config_;
  config_ = NULL;
  return temp;
}
inline void CqCreateStorage::set_allocated_config(::Db::Proto::StorageConfig* config) {
  delete config_;
  config_ = config;
  if (config) {
    set_has_config();
  } else {
    clear_has_config();
  }
  // @@protoc_insertion_point(field_set_allocated:Api.Proto.CqCreateStorage.config)
}

// -------------------------------------------------------------------

// CqCreateView

// optional string driver = 1;
inline bool CqCreateView::has_driver() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CqCreateView::set_has_driver() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CqCreateView::clear_has_driver() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CqCreateView::clear_driver() {
  driver_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_driver();
}
inline const ::std::string& CqCreateView::driver() const {
  // @@protoc_insertion_point(field_get:Api.Proto.CqCreateView.driver)
  return driver_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CqCreateView::set_driver(const ::std::string& value) {
  set_has_driver();
  driver_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Api.Proto.CqCreateView.driver)
}
inline void CqCreateView::set_driver(const char* value) {
  set_has_driver();
  driver_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Api.Proto.CqCreateView.driver)
}
inline void CqCreateView::set_driver(const char* value, size_t size) {
  set_has_driver();
  driver_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Api.Proto.CqCreateView.driver)
}
inline ::std::string* CqCreateView::mutable_driver() {
  set_has_driver();
  // @@protoc_insertion_point(field_mutable:Api.Proto.CqCreateView.driver)
  return driver_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* CqCreateView::release_driver() {
  // @@protoc_insertion_point(field_release:Api.Proto.CqCreateView.driver)
  clear_has_driver();
  return driver_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CqCreateView::set_allocated_driver(::std::string* driver) {
  if (driver != NULL) {
    set_has_driver();
  } else {
    clear_has_driver();
  }
  driver_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), driver);
  // @@protoc_insertion_point(field_set_allocated:Api.Proto.CqCreateView.driver)
}

// optional string identifier = 2;
inline bool CqCreateView::has_identifier() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CqCreateView::set_has_identifier() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CqCreateView::clear_has_identifier() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CqCreateView::clear_identifier() {
  identifier_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_identifier();
}
inline const ::std::string& CqCreateView::identifier() const {
  // @@protoc_insertion_point(field_get:Api.Proto.CqCreateView.identifier)
  return identifier_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CqCreateView::set_identifier(const ::std::string& value) {
  set_has_identifier();
  identifier_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Api.Proto.CqCreateView.identifier)
}
inline void CqCreateView::set_identifier(const char* value) {
  set_has_identifier();
  identifier_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Api.Proto.CqCreateView.identifier)
}
inline void CqCreateView::set_identifier(const char* value, size_t size) {
  set_has_identifier();
  identifier_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Api.Proto.CqCreateView.identifier)
}
inline ::std::string* CqCreateView::mutable_identifier() {
  set_has_identifier();
  // @@protoc_insertion_point(field_mutable:Api.Proto.CqCreateView.identifier)
  return identifier_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* CqCreateView::release_identifier() {
  // @@protoc_insertion_point(field_release:Api.Proto.CqCreateView.identifier)
  clear_has_identifier();
  return identifier_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CqCreateView::set_allocated_identifier(::std::string* identifier) {
  if (identifier != NULL) {
    set_has_identifier();
  } else {
    clear_has_identifier();
  }
  identifier_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), identifier);
  // @@protoc_insertion_point(field_set_allocated:Api.Proto.CqCreateView.identifier)
}

// optional .Db.Proto.ViewConfig config = 3;
inline bool CqCreateView::has_config() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CqCreateView::set_has_config() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CqCreateView::clear_has_config() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CqCreateView::clear_config() {
  if (config_ != NULL) config_->::Db::Proto::ViewConfig::Clear();
  clear_has_config();
}
inline const ::Db::Proto::ViewConfig& CqCreateView::config() const {
  // @@protoc_insertion_point(field_get:Api.Proto.CqCreateView.config)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return config_ != NULL ? *config_ : *default_instance().config_;
#else
  return config_ != NULL ? *config_ : *default_instance_->config_;
#endif
}
inline ::Db::Proto::ViewConfig* CqCreateView::mutable_config() {
  set_has_config();
  if (config_ == NULL) {
    config_ = new ::Db::Proto::ViewConfig;
  }
  // @@protoc_insertion_point(field_mutable:Api.Proto.CqCreateView.config)
  return config_;
}
inline ::Db::Proto::ViewConfig* CqCreateView::release_config() {
  // @@protoc_insertion_point(field_release:Api.Proto.CqCreateView.config)
  clear_has_config();
  ::Db::Proto::ViewConfig* temp = config_;
  config_ = NULL;
  return temp;
}
inline void CqCreateView::set_allocated_config(::Db::Proto::ViewConfig* config) {
  delete config_;
  config_ = config;
  if (config) {
    set_has_config();
  } else {
    clear_has_config();
  }
  // @@protoc_insertion_point(field_set_allocated:Api.Proto.CqCreateView.config)
}

// -------------------------------------------------------------------

// CqUnlinkStorage

// required string identifier = 1;
inline bool CqUnlinkStorage::has_identifier() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CqUnlinkStorage::set_has_identifier() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CqUnlinkStorage::clear_has_identifier() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CqUnlinkStorage::clear_identifier() {
  identifier_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_identifier();
}
inline const ::std::string& CqUnlinkStorage::identifier() const {
  // @@protoc_insertion_point(field_get:Api.Proto.CqUnlinkStorage.identifier)
  return identifier_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CqUnlinkStorage::set_identifier(const ::std::string& value) {
  set_has_identifier();
  identifier_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Api.Proto.CqUnlinkStorage.identifier)
}
inline void CqUnlinkStorage::set_identifier(const char* value) {
  set_has_identifier();
  identifier_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Api.Proto.CqUnlinkStorage.identifier)
}
inline void CqUnlinkStorage::set_identifier(const char* value, size_t size) {
  set_has_identifier();
  identifier_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Api.Proto.CqUnlinkStorage.identifier)
}
inline ::std::string* CqUnlinkStorage::mutable_identifier() {
  set_has_identifier();
  // @@protoc_insertion_point(field_mutable:Api.Proto.CqUnlinkStorage.identifier)
  return identifier_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* CqUnlinkStorage::release_identifier() {
  // @@protoc_insertion_point(field_release:Api.Proto.CqUnlinkStorage.identifier)
  clear_has_identifier();
  return identifier_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CqUnlinkStorage::set_allocated_identifier(::std::string* identifier) {
  if (identifier != NULL) {
    set_has_identifier();
  } else {
    clear_has_identifier();
  }
  identifier_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), identifier);
  // @@protoc_insertion_point(field_set_allocated:Api.Proto.CqUnlinkStorage.identifier)
}

// -------------------------------------------------------------------

// CqUnlinkView

// required string identifier = 1;
inline bool CqUnlinkView::has_identifier() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CqUnlinkView::set_has_identifier() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CqUnlinkView::clear_has_identifier() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CqUnlinkView::clear_identifier() {
  identifier_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_identifier();
}
inline const ::std::string& CqUnlinkView::identifier() const {
  // @@protoc_insertion_point(field_get:Api.Proto.CqUnlinkView.identifier)
  return identifier_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CqUnlinkView::set_identifier(const ::std::string& value) {
  set_has_identifier();
  identifier_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Api.Proto.CqUnlinkView.identifier)
}
inline void CqUnlinkView::set_identifier(const char* value) {
  set_has_identifier();
  identifier_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Api.Proto.CqUnlinkView.identifier)
}
inline void CqUnlinkView::set_identifier(const char* value, size_t size) {
  set_has_identifier();
  identifier_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Api.Proto.CqUnlinkView.identifier)
}
inline ::std::string* CqUnlinkView::mutable_identifier() {
  set_has_identifier();
  // @@protoc_insertion_point(field_mutable:Api.Proto.CqUnlinkView.identifier)
  return identifier_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* CqUnlinkView::release_identifier() {
  // @@protoc_insertion_point(field_release:Api.Proto.CqUnlinkView.identifier)
  clear_has_identifier();
  return identifier_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CqUnlinkView::set_allocated_identifier(::std::string* identifier) {
  if (identifier != NULL) {
    set_has_identifier();
  } else {
    clear_has_identifier();
  }
  identifier_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), identifier);
  // @@protoc_insertion_point(field_set_allocated:Api.Proto.CqUnlinkView.identifier)
}

// -------------------------------------------------------------------

// CqUploadExtern

// required string file_name = 1;
inline bool CqUploadExtern::has_file_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CqUploadExtern::set_has_file_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CqUploadExtern::clear_has_file_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CqUploadExtern::clear_file_name() {
  file_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_file_name();
}
inline const ::std::string& CqUploadExtern::file_name() const {
  // @@protoc_insertion_point(field_get:Api.Proto.CqUploadExtern.file_name)
  return file_name_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CqUploadExtern::set_file_name(const ::std::string& value) {
  set_has_file_name();
  file_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Api.Proto.CqUploadExtern.file_name)
}
inline void CqUploadExtern::set_file_name(const char* value) {
  set_has_file_name();
  file_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Api.Proto.CqUploadExtern.file_name)
}
inline void CqUploadExtern::set_file_name(const char* value, size_t size) {
  set_has_file_name();
  file_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Api.Proto.CqUploadExtern.file_name)
}
inline ::std::string* CqUploadExtern::mutable_file_name() {
  set_has_file_name();
  // @@protoc_insertion_point(field_mutable:Api.Proto.CqUploadExtern.file_name)
  return file_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* CqUploadExtern::release_file_name() {
  // @@protoc_insertion_point(field_release:Api.Proto.CqUploadExtern.file_name)
  clear_has_file_name();
  return file_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CqUploadExtern::set_allocated_file_name(::std::string* file_name) {
  if (file_name != NULL) {
    set_has_file_name();
  } else {
    clear_has_file_name();
  }
  file_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), file_name);
  // @@protoc_insertion_point(field_set_allocated:Api.Proto.CqUploadExtern.file_name)
}

// required bytes buffer = 2;
inline bool CqUploadExtern::has_buffer() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CqUploadExtern::set_has_buffer() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CqUploadExtern::clear_has_buffer() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CqUploadExtern::clear_buffer() {
  buffer_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_buffer();
}
inline const ::std::string& CqUploadExtern::buffer() const {
  // @@protoc_insertion_point(field_get:Api.Proto.CqUploadExtern.buffer)
  return buffer_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CqUploadExtern::set_buffer(const ::std::string& value) {
  set_has_buffer();
  buffer_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Api.Proto.CqUploadExtern.buffer)
}
inline void CqUploadExtern::set_buffer(const char* value) {
  set_has_buffer();
  buffer_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Api.Proto.CqUploadExtern.buffer)
}
inline void CqUploadExtern::set_buffer(const void* value, size_t size) {
  set_has_buffer();
  buffer_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Api.Proto.CqUploadExtern.buffer)
}
inline ::std::string* CqUploadExtern::mutable_buffer() {
  set_has_buffer();
  // @@protoc_insertion_point(field_mutable:Api.Proto.CqUploadExtern.buffer)
  return buffer_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* CqUploadExtern::release_buffer() {
  // @@protoc_insertion_point(field_release:Api.Proto.CqUploadExtern.buffer)
  clear_has_buffer();
  return buffer_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CqUploadExtern::set_allocated_buffer(::std::string* buffer) {
  if (buffer != NULL) {
    set_has_buffer();
  } else {
    clear_has_buffer();
  }
  buffer_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), buffer);
  // @@protoc_insertion_point(field_set_allocated:Api.Proto.CqUploadExtern.buffer)
}

// -------------------------------------------------------------------

// CqDownloadExtern

// required string file_name = 1;
inline bool CqDownloadExtern::has_file_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CqDownloadExtern::set_has_file_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CqDownloadExtern::clear_has_file_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CqDownloadExtern::clear_file_name() {
  file_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_file_name();
}
inline const ::std::string& CqDownloadExtern::file_name() const {
  // @@protoc_insertion_point(field_get:Api.Proto.CqDownloadExtern.file_name)
  return file_name_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CqDownloadExtern::set_file_name(const ::std::string& value) {
  set_has_file_name();
  file_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Api.Proto.CqDownloadExtern.file_name)
}
inline void CqDownloadExtern::set_file_name(const char* value) {
  set_has_file_name();
  file_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Api.Proto.CqDownloadExtern.file_name)
}
inline void CqDownloadExtern::set_file_name(const char* value, size_t size) {
  set_has_file_name();
  file_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Api.Proto.CqDownloadExtern.file_name)
}
inline ::std::string* CqDownloadExtern::mutable_file_name() {
  set_has_file_name();
  // @@protoc_insertion_point(field_mutable:Api.Proto.CqDownloadExtern.file_name)
  return file_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* CqDownloadExtern::release_file_name() {
  // @@protoc_insertion_point(field_release:Api.Proto.CqDownloadExtern.file_name)
  clear_has_file_name();
  return file_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CqDownloadExtern::set_allocated_file_name(::std::string* file_name) {
  if (file_name != NULL) {
    set_has_file_name();
  } else {
    clear_has_file_name();
  }
  file_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), file_name);
  // @@protoc_insertion_point(field_set_allocated:Api.Proto.CqDownloadExtern.file_name)
}

// -------------------------------------------------------------------

// CqShutdown

// -------------------------------------------------------------------

// SrFin_MutationInfo

// optional int64 document_id = 1;
inline bool SrFin_MutationInfo::has_document_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SrFin_MutationInfo::set_has_document_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SrFin_MutationInfo::clear_has_document_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SrFin_MutationInfo::clear_document_id() {
  document_id_ = GOOGLE_LONGLONG(0);
  clear_has_document_id();
}
inline ::google::protobuf::int64 SrFin_MutationInfo::document_id() const {
  // @@protoc_insertion_point(field_get:Api.Proto.SrFin.MutationInfo.document_id)
  return document_id_;
}
inline void SrFin_MutationInfo::set_document_id(::google::protobuf::int64 value) {
  set_has_document_id();
  document_id_ = value;
  // @@protoc_insertion_point(field_set:Api.Proto.SrFin.MutationInfo.document_id)
}

// -------------------------------------------------------------------

// SrFin

// optional .Api.Proto.ErrorCode error = 1;
inline bool SrFin::has_error() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SrFin::set_has_error() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SrFin::clear_has_error() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SrFin::clear_error() {
  error_ = 0;
  clear_has_error();
}
inline ::Api::Proto::ErrorCode SrFin::error() const {
  // @@protoc_insertion_point(field_get:Api.Proto.SrFin.error)
  return static_cast< ::Api::Proto::ErrorCode >(error_);
}
inline void SrFin::set_error(::Api::Proto::ErrorCode value) {
  assert(::Api::Proto::ErrorCode_IsValid(value));
  set_has_error();
  error_ = value;
  // @@protoc_insertion_point(field_set:Api.Proto.SrFin.error)
}

// optional int64 transaction_id = 2;
inline bool SrFin::has_transaction_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SrFin::set_has_transaction_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SrFin::clear_has_transaction_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SrFin::clear_transaction_id() {
  transaction_id_ = GOOGLE_LONGLONG(0);
  clear_has_transaction_id();
}
inline ::google::protobuf::int64 SrFin::transaction_id() const {
  // @@protoc_insertion_point(field_get:Api.Proto.SrFin.transaction_id)
  return transaction_id_;
}
inline void SrFin::set_transaction_id(::google::protobuf::int64 value) {
  set_has_transaction_id();
  transaction_id_ = value;
  // @@protoc_insertion_point(field_set:Api.Proto.SrFin.transaction_id)
}

// optional int64 sequence_id = 3;
inline bool SrFin::has_sequence_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SrFin::set_has_sequence_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SrFin::clear_has_sequence_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SrFin::clear_sequence_id() {
  sequence_id_ = GOOGLE_LONGLONG(0);
  clear_has_sequence_id();
}
inline ::google::protobuf::int64 SrFin::sequence_id() const {
  // @@protoc_insertion_point(field_get:Api.Proto.SrFin.sequence_id)
  return sequence_id_;
}
inline void SrFin::set_sequence_id(::google::protobuf::int64 value) {
  set_has_sequence_id();
  sequence_id_ = value;
  // @@protoc_insertion_point(field_set:Api.Proto.SrFin.sequence_id)
}

// repeated .Api.Proto.SrFin.MutationInfo mutations = 4;
inline int SrFin::mutations_size() const {
  return mutations_.size();
}
inline void SrFin::clear_mutations() {
  mutations_.Clear();
}
inline const ::Api::Proto::SrFin_MutationInfo& SrFin::mutations(int index) const {
  // @@protoc_insertion_point(field_get:Api.Proto.SrFin.mutations)
  return mutations_.Get(index);
}
inline ::Api::Proto::SrFin_MutationInfo* SrFin::mutable_mutations(int index) {
  // @@protoc_insertion_point(field_mutable:Api.Proto.SrFin.mutations)
  return mutations_.Mutable(index);
}
inline ::Api::Proto::SrFin_MutationInfo* SrFin::add_mutations() {
  // @@protoc_insertion_point(field_add:Api.Proto.SrFin.mutations)
  return mutations_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::Api::Proto::SrFin_MutationInfo >*
SrFin::mutable_mutations() {
  // @@protoc_insertion_point(field_mutable_list:Api.Proto.SrFin.mutations)
  return &mutations_;
}
inline const ::google::protobuf::RepeatedPtrField< ::Api::Proto::SrFin_MutationInfo >&
SrFin::mutations() const {
  // @@protoc_insertion_point(field_list:Api.Proto.SrFin.mutations)
  return mutations_;
}

// -------------------------------------------------------------------

// SrRows

// repeated bytes row_data = 1;
inline int SrRows::row_data_size() const {
  return row_data_.size();
}
inline void SrRows::clear_row_data() {
  row_data_.Clear();
}
inline const ::std::string& SrRows::row_data(int index) const {
  // @@protoc_insertion_point(field_get:Api.Proto.SrRows.row_data)
  return row_data_.Get(index);
}
inline ::std::string* SrRows::mutable_row_data(int index) {
  // @@protoc_insertion_point(field_mutable:Api.Proto.SrRows.row_data)
  return row_data_.Mutable(index);
}
inline void SrRows::set_row_data(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:Api.Proto.SrRows.row_data)
  row_data_.Mutable(index)->assign(value);
}
inline void SrRows::set_row_data(int index, const char* value) {
  row_data_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:Api.Proto.SrRows.row_data)
}
inline void SrRows::set_row_data(int index, const void* value, size_t size) {
  row_data_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Api.Proto.SrRows.row_data)
}
inline ::std::string* SrRows::add_row_data() {
  // @@protoc_insertion_point(field_add_mutable:Api.Proto.SrRows.row_data)
  return row_data_.Add();
}
inline void SrRows::add_row_data(const ::std::string& value) {
  row_data_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:Api.Proto.SrRows.row_data)
}
inline void SrRows::add_row_data(const char* value) {
  row_data_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:Api.Proto.SrRows.row_data)
}
inline void SrRows::add_row_data(const void* value, size_t size) {
  row_data_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:Api.Proto.SrRows.row_data)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
SrRows::row_data() const {
  // @@protoc_insertion_point(field_list:Api.Proto.SrRows.row_data)
  return row_data_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
SrRows::mutable_row_data() {
  // @@protoc_insertion_point(field_mutable_list:Api.Proto.SrRows.row_data)
  return &row_data_;
}

// -------------------------------------------------------------------

// SrBlob

// required bytes buffer = 1;
inline bool SrBlob::has_buffer() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SrBlob::set_has_buffer() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SrBlob::clear_has_buffer() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SrBlob::clear_buffer() {
  buffer_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_buffer();
}
inline const ::std::string& SrBlob::buffer() const {
  // @@protoc_insertion_point(field_get:Api.Proto.SrBlob.buffer)
  return buffer_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SrBlob::set_buffer(const ::std::string& value) {
  set_has_buffer();
  buffer_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Api.Proto.SrBlob.buffer)
}
inline void SrBlob::set_buffer(const char* value) {
  set_has_buffer();
  buffer_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Api.Proto.SrBlob.buffer)
}
inline void SrBlob::set_buffer(const void* value, size_t size) {
  set_has_buffer();
  buffer_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Api.Proto.SrBlob.buffer)
}
inline ::std::string* SrBlob::mutable_buffer() {
  set_has_buffer();
  // @@protoc_insertion_point(field_mutable:Api.Proto.SrBlob.buffer)
  return buffer_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SrBlob::release_buffer() {
  // @@protoc_insertion_point(field_release:Api.Proto.SrBlob.buffer)
  clear_has_buffer();
  return buffer_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SrBlob::set_allocated_buffer(::std::string* buffer) {
  if (buffer != NULL) {
    set_has_buffer();
  } else {
    clear_has_buffer();
  }
  buffer_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), buffer);
  // @@protoc_insertion_point(field_set_allocated:Api.Proto.SrBlob.buffer)
}

#endif  // !PROTOBUF_INLINE_NOT_IN_HEADERS
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace Proto
}  // namespace Api

#ifndef SWIG
namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::Api::Proto::Mutation_Type> : ::google::protobuf::internal::true_type {};
template <> struct is_proto_enum< ::Api::Proto::Constraint_Type> : ::google::protobuf::internal::true_type {};
template <> struct is_proto_enum< ::Api::Proto::CqApply_Type> : ::google::protobuf::internal::true_type {};
template <> struct is_proto_enum< ::Api::Proto::ErrorCode> : ::google::protobuf::internal::true_type {};
template <> struct is_proto_enum< ::Api::Proto::ClientRequests> : ::google::protobuf::internal::true_type {};
template <> struct is_proto_enum< ::Api::Proto::ServerResponses> : ::google::protobuf::internal::true_type {};

}  // namespace protobuf
}  // namespace google
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_proto_2fApi_2eproto__INCLUDED
